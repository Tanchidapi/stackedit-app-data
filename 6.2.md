# 6.2
## 题目一
### 给定两个整数n和k，表示长为n的数组，在0s时所有值都为1，每经过1s，第i个数的值变为前一秒到i的所有数的和，问第ks时最后一个数的值。第一个数恒为1。
#### eg：
```c++
>>>n = 4, k = 5
56
```
题目标签为模拟，一开始尝试用模拟的方法去做，在单数组的情况下发现直接操作会变成第ts时第i个数为其前一秒加上这一秒在它之前所有数的和，不符合题意，改为用两个数组模拟，互相放置前一秒结果和计算的当前时间结果，但时间复杂度会超（O(n^2)），随后想到动态规划，第ts时第i个数的值要变为它本身加上这一秒第i - 1个数的值，从第2个数开始更新，则满足题目要求，题解如下
```c++
class Solution {
public:
	int valueAfterKSeconds(int n, int k) {
	int *dp = (int *)malloc(n * sizeof(int));
	for(int i = 0; i < n; i++) dp[i] = 1;
	for(int i = 0; i < k; i++){
		for(int j = 1; j < n; j++){
			dp[j] += dp[j - 1];
			dp[j] %= 1000000007;
		}
	}
	return dp[n - 1];
	}
};
```
## 题目二
### 给一颗二叉树，节点个数为奇数个，两位玩家分别进行染色，玩家一染红色，玩家二染蓝色，玩家一先手，在给定玩家一第一个染色点的情况下，判断玩家二是否能
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyMjcxODgyMjYsLTE0MzEwNTY3NzcsLT
IxMzM4NzA3MjBdfQ==
-->