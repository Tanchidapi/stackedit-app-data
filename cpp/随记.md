### 引用
引用就是别名，指向赋值对象的同一内存地址
引用要注意两点，一是引用必须初始化，二是引用赋值后不可更改。引用作函数参数时效果与指针一致，但是比指针更清晰易懂
引用作返回值时要注意，不要返回局部变量的引用，同时返回值为引用的函数调用可以作为左值
引用的本质是一个指针常量，因此可以解释前面说到需注意的两点，它指向一个赋值后不变的地址
引用必须指向合法的内存空间，不能指向常量
常量引用可以用于修饰形参，防止误操作，常量引用可以指向常量，本质是编译器帮忙创建了常量存放的地址空间
常量引用和常量定义一样，指向不可修改
### 函数
cpp中函数可以有默认参数，在参数缺少时使用缺省值，从第一个开始有默认值的参数开始，后续参数都要有默认参数
函数声明中有默认参数，则函数实现不能有默认参数
形参列表中还可以有占位参数，用于说明参数类型，调用函数时必须填补该位置，占位也可以有默认值
函数重载：多态的实现方法之一，即同名函数实现不同功能，重载可以在同一个作用域下，函数名称相同但是函数参数的类型/个数/顺序不同，但是函数的返回值不能作为重载的条件，函数重载的核心还是要避免出现二义性
### 类与对象
cpp中的struct和class唯一区别在于默认访问权限不同，struct默认权限public，class默认权限private
将类拆分为头文件和源文件编写时，类似于函数的写法，在头文件中注意添加`#pragma once`声明防止重复包含，在其中仅声明类名及其中的一系列权限下的属性和方法；在源文件中头部包含对应头文件，然后仅需书写各方法的具体实现，方法名需要修改为`类名::方法名`以指定作用域

cpp类的拆分书写类似于java，但是写起来更麻烦，因需要考虑文件的包含依赖关系

**循环（重复）包含避免：**
···

对象的初始化和清理：
初始化通过构造函数实现，清理通过析构函数实现，这两个函数会被编译器自动调用，并且这两件工作是编译器强制执行的，如果不实现这两个函数，编译器会提供对应的**空实现**函数（还有一个默认拷贝构造，复制所有属性值）
若已经提供有参构造，则编译器不再提供默认空无参
若已经提供拷贝，则编译器不再提供其他构造

构造函数：
构造函数不需要返回值，函数名和类名相同，可以有参数与重载，创建对象时自动调用且一次
可分为有参/无参构造或者普通/拷贝构造
拷贝构造就是传入一个同类的常量引用对象，然后就可以将传入的常量引用对象中的属性拷贝到当前对象中

有三种调用方法：括号法、显示法和隐式转换法
使用默认/无参构造时不加括号，防止编译器误认为函数声明；显示法就是用括号法创建了一个匿名对象，然后将该匿名对象赋值给对应的对象名，对匿名对象，当前行执行后会被立即回收（如果没有赋值），注意不要使用拷贝构造初始化匿名对象，会被认为是对象声明（无参构造），造成重定义；隐式转换法就是直接用赋值语句写参数

使用拷贝构造的时机：用已有对象初始化新对象，值传递方式给函数参数传值，值方式返回局部函数。
值传递会出现拷贝构造的原因是因为值传递本质是创建一个参数的“副本”，如果参数是值类型的类，就会出现拷贝构造
值返回一个类的对象，逻辑拆开来和隐式转换法是一样的

浅拷贝和深拷贝：
浅拷贝就是简单的赋值拷贝操作，深拷贝是在堆区重新申请空间，进行拷贝操作，编译器提供的默认拷贝为浅拷贝
浅拷贝在属性中有指针时容易出现问题，因为浅拷贝对于指针属性是直接将其装有的地址值直接复制，容易造成重复释放（段错误）

初始化列表，类似于有参构造，在构造函数名后面用`:`加上属性和对应初值即可

析构函数：
析构函数不需要返回值，函数名为类名前面加上`~`，不能有参数，不能重载，在对象销毁前自动调用且一次

类对象作为类成员时，创建对象的顺序是由内到外的，析构顺序则相反

cpp中类的静态属性和静态函数与java中的一致，需要在类内声明，在类外初始化（常量可以在类内初始化，但是建议统一在类外进行），类外访问时需注意权限，如果为private或者protected，使用类名是访问不了的

类的存储：
空对象页占用1B的内存空间，是为了区分空对象占内存的位置，对象拥有对应的内存地址，静态成员变量/函数和成员函数不占对象的内存空间，对象的内存空间只考虑非静态成员变量

this指针指向的是对应对象，本质是一个指针常量，用于区分重名参数和返回对象本身（用*this）。要注意的是返回对象本身时返回值类型应该是对应的引用类型，值返回和值传递一样，内容本质上是一个拷贝，因此如果要用链式调用的方式或者其他对同一个对象进行连续操作，返回值要是引用类型
指向null的类对象指针可以调用对应的类中的方法，但是前提是方法中没有this指针（访问成员变量时默认前面有this指针，表示访问当前对象的变量）

常函数是类中成员函数**后加**const的函数，内部不可用修改成员属性，但是如果成员属性声明时加关键字mutable则可以，本质上函数后面的const修饰的是this，把this变成了常量指针常量
声明对象前加const称该对象为常对象，常对象只能调用常函数

友元的目的是让一个函数或者类访问另一个类中的私有成员，关键字为friend，有三种实现方式：全局函数做友元，类做友元，成员函数做友元
### 运算符重载
概念：对已有运算符重新定义，赋予另外功能，适应不同数据类型。实现方法有通过成员函数重载和全局函数重载，本质是一样的，如：
`返回值  operator+ （参数）{函数逻辑}`
使用方法为`y = x.operator+(参数)`或者直接`z = x + y`
其中x、y、z要和参数/返回值的类型一致
内置数据类型的表达式不能使用运算符重载

左移运算符重载：
可以输出自定义的数据类型，通常不会使用成员函数重载，因为要保持cout在左边，利用全局函数重载，如：
`ostream& operator<<(ostream &cout, 参数) { 函数逻辑(return cout) }`
使用方法和cout正常用法一致
cout在定义中可以看到，它是一个输出流（ostream）对象，该对象全局只有一个，因此要用引用的方式进行传参，防止出现拷贝。同时基于链式编程思想，想要在重载的<<后仍能继续使用<<，则返回值应该为cout的引用，理由同样如上

递增运算符重载：
实现自定义整形变量。存在两种，前置递增和后置递增，可以用成员函数实现重载，如：
前置
`类名& operator++() { 函数逻辑(return *this) }`
后置
`类名 operator(int) { 函数逻辑，需要先记录当前值，递增后再将记录值返回(return temp) }`
使用方法和++正常用法一致
前置递增返回值用类名的引用并在最后返回对象本身是为了保证在连续前置递增的情况下，都是对同一个对象进行操作，因为如果是值返回，则会出现拷贝的情况。
后置递增可以是值返回，因为后置递增要返回的是记录值，而记录值是一个存储在栈上的临时变量。后置参数需要使用一个int占位符以实现和前置的区别重载，因为是值返回，所以后置递增不能连续使用

赋值运算符重载：
实际上，编译器为一个类提供四个初始函数，默认的无参构造、默认的无参析构、默认的拷贝构造、和赋值重载，赋值重载的功能是对属性进行值拷贝。重载时需要注意深浅拷贝，可以在成员函数中实现，如：
`类型& operator=(类型&) { 函数逻辑(return *this) }`
是使用方法和=正常用法一致
参数要传入引用的原因是避免拷贝的开销，返回值为类型的引用可以保证连续等号的使用，返回自身的引用

关系运算符重载：
实现自定义数据类型的比较，可以在成员函数中实现，如：
`bool operator==(参数&) { 函数逻辑(return true/false) }`
使用方法和==正常用法一致
实现其他关系运算符方法同理

函数调用运算符重载：
即对小括号`()`的重载，重载后使用的方式很像函数调用，因此称为仿函数，仿函数没有固定写法，十分灵活，可以在成员函数中实现，如：
`返回值 operator()(参数) { 函数逻辑 }`
使用方法类似函数（仿函数）
可以利用匿名对象实现匿名函数对象，即先创建一个匿名对象再调用仿函数

### 继承
继承技术可以实现代码复用，基本语法如下：
`class A: public class B { 类内容 }`
引号`:`后的权限指明了继承的方式
继承方式有三种：公共（public）、保护（protected）、私有（private）
public继承会使父类中对应权限（除private外）的成员按原有权限继承到子类中
protected继承会把public权限的成员变成protected
private继承会把public和protected变为private
注意私有属性只是被隐藏了，子类无法访问，但还是继承了
Windows下可以利用vs的开发人员命令提示工具查看对象模型，跳转到对应文件下用命令
`cl /d1 reportSingleClassLayout类名 文件名`  


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE4NTQzMjkxNiwtMTA1Nzc4OTA3NCwtMT
I4NjcxODU5MywtMTk2NTM1MzUzOCwtOTA5MzgxNTYyLC05MDkz
ODE1NjIsLTg4MDA1MDQ0MywxOTYzNDM0NjU0LDkwNTU2NDk3NC
wtMTMzMTU4MzE4LDcxMzgxOTEyMywtMTgyNjAzMDQyOSwxNzE0
Nzc0MzM3LC0xMDIzMzQ3OTEsLTE2NTAwMTgwMjAsLTQwNzkxMT
I2MSw1MjU4NzgxNDAsMTU1OTQ1NTY1MywzNTExOTk0NzgsLTYz
OTgzMjY5MF19
-->