### 引用
引用就是别名，指向赋值对象的同一内存地址
引用要注意两点，一是引用必须初始化，二是引用赋值后不可更改。引用作函数参数时效果与指针一致，但是比指针更清晰易懂
引用作返回值时要注意，不要返回局部变量的引用，同时返回值为引用的函数调用可以作为左值
引用的本质是一个指针常量，因此可以解释前面说到需注意的两点，它指向一个赋值后不变的地址
引用必须指向合法的内存空间，不能指向常量
常量引用可以用于修饰形参，防止误操作，常量引用可以指向常量，本质是编译器帮忙创建了常量存放的地址空间
常量引用和常量定义一样，指向不可修改
### 函数
cpp中函数可以有默认参数，在参数缺少时使用缺省值，从第一个开始有默认值的参数开始，后续参数都要有默认参数
函数声明中有默认参数，则函数实现不能有默认参数
形参列表中还可以有占位参数，用于说明参数类型，调用函数时必须填补该位置，占位也可以有默认值
函数重载：多态的实现方法之一，即同名函数实现不同功能，重载可以在同一个作用域下，函数名称相同但是函数参数的类型/个数/顺序不同，但是函数的返回值不能作为重载的条件，函数重载的核心还是要避免出现二义性
### 类与对象
cpp中的struct和class唯一区别在于默认访问权限不同，struct默认权限public，class默认权限private
将类拆分为头文件和源文件编写时，类似于函数的写法，在头文件中注意添加`#pragma once`声明防止重复包含，在其中仅声明类名及其中的一系列权限下的属性和方法；在源文件中头部包含对应头文件，然后仅需书写各方法的具体实现，方法名需要修改为`类名::方法名`以指定作用域

cpp类的拆分书写类似于java，但是写起来更麻烦，因需要考虑文件的包含依赖关系

**循环（重复）包含避免：**
···

对象的初始化和清理：
初始化通过构造函数实现，清理通过析构函数实现，这两个函数会被编译器自动调用，并且这两件工作是编译器强制执行的，如果不实现这两个函数，编译器会提供对应的**空实现**函数（还有一个默认拷贝构造，复制所有属性值）
若已经提供有参构造，则编译器不再提供默认空无参
若已经提供拷贝，则编译器不再提供其他构造

构造函数：
构造函数不需要返回值，函数名和类名相同，可以有参数与重载，创建对象时自动调用且一次
可分为有参/无参构造或者普通/拷贝构造
拷贝构造就是传入一个同类的常量引用对象，然后就可以将传入的常量引用对象中的属性拷贝到当前对象中

有三种调用方法：括号法、显示法和隐式转换法
使用默认/无参构造时不加括号，防止编译器误认为函数声明；显示法就是用括号法创建了一个匿名对象，然后将该匿名对象赋值给对应的对象名，对匿名对象，当前行执行后会被立即回收（如果没有赋值），注意不要使用拷贝构造初始化匿名对象，会被认为是对象声明（无参构造），造成重定义；隐式转换法就是直接用赋值语句写参数

使用拷贝构造的时机：用已有对象初始化新对象，值传递方式给函数参数传值，值方式返回局部函数。
值传递会出现拷贝构造的原因是因为值传递本质是创建一个参数的“副本”，如果参数是值类型的类，就会出现拷贝构造
值返回一个类的对象，逻辑拆开来和隐式转换法是一样的

浅拷贝和深拷贝：
浅拷贝就是简单的赋值拷贝操作，深拷贝是在堆区重新申请空间，进行拷贝操作，编译器提供的默认拷贝为浅拷贝
浅拷贝在属性中有指针时容易出现问题，因为浅拷贝对于指针属性是直接将其装有的地址值直接复制，容易造成重复释放（段错误）

初始化列表，类似于有参构造，在构造函数名后面用`:`加上属性和对应初值即可

析构函数：
析构函数不需要返回值，函数名为类名前面加上`~`，不能有参数，不能重载，在对象销毁前自动调用且一次

类对象作为类成员时，创建对象的顺序是由内到外的，析构顺序则相反

cpp中类的静态属性和静态函数与java中的一致，需要在类内声明，在类外初始化（常量可以在类内初始化，但是建议统一在类外进行），类外访问时需注意权限，如果为private或者protected，使用类名是访问不了的

类的存储：
空对象页占用1B的内存空间，是为了区分空对象占内存的位置，对象拥有对应的内存地址，静态成员变量/函数和成员函数不占对象的内存空间，对象的内存空间只考虑非静态成员变量

this指针指向的是对应对象，本质是一个指针常量，用于区分重名参数和返回对象本身（用*this）。要注意的是返回对象本身时返回值类型应该是对应的引用类型，值返回和值传递一样，内容本质上是一个拷贝，因此如果要用链式调用的方式或者其他对同一个对象进行连续操作，返回值要是引用类型
指向null的类对象指针可以调用对应的类中的方法，但是前提是方法中没有this指针（访问成员变量时默认前面有this指针，表示访问当前对象的变量）

常函数是类中成员函数**后加**const的函数，内部不可用修改成员属性，但是如果成员属性声明时加关键字mutable则可以，本质上函数后面的const修饰的是this，把this变成了常量指针常量
声明对象前加const称该对象为常对象，常对象只能调用常函数

友元的目的是让一个函数或者类访问另一个类中的私有成员，关键字为friend，有三种实现方式：全局函数做友元，类做友元，成员函数做友元
### 运算符重载
概念：对已有运算符重新定义，赋予另外功能，适应不同数据类型。实现方法有通过成员函数重载和全局函数重载，本质是一样的，如：
`返回值  operator+ （参数）{函数逻辑}`
使用方法为`y = x.operator+(参数)`或者直接`z = x + y`
其中x、y、z要和参数/返回值的类型一致
内置数据类型的表达式不能使用运算符重载

左移运算符重载：
可以输出自定义的数据类型，通常不会使用成员函数重载，因为要保持cout在左边，利用全局函数重载，如：
`ostream& operator<<(ostream &cout, 参数) { 函数逻辑(return cout) }`
使用方法和cout正常用法一致
cout在定义中可以看到，它是一个输出流（ostream）对象，该对象全局只有一个，因此要用引用的方式进行传参，防止出现拷贝。同时基于链式编程思想，想要在重载的<<后仍能继续使用<<，则返回值应该为cout的引用，理由同样如上

递增运算符重载：
实现自定义整形变量。存在两种，前置递增和后置递增，可以用成员函数实现重载，如：
前置
`类名& operator++() { 函数逻辑(return *this) }`
后置
`类名 operator++(int) { 函数逻辑，需要先记录当前值，递增后再将记录值返回(return temp) }`
使用方法和++正常用法一致
前置递增返回值用类名的引用并在最后返回对象本身是为了保证在连续前置递增的情况下，都是对同一个对象进行操作，因为如果是值返回，则会出现拷贝的情况。
后置递增可以是值返回，因为后置递增要返回的是记录值，而记录值是一个存储在栈上的临时变量。后置参数需要使用一个int占位符以实现和前置的区别重载，因为是值返回，所以后置递增不能连续使用

赋值运算符重载：
实际上，编译器为一个类提供四个初始函数，默认的无参构造、默认的无参析构、默认的拷贝构造、和赋值重载，赋值重载的功能是对属性进行值拷贝。重载时需要注意深浅拷贝，可以在成员函数中实现，如：
`类型& operator=(类型&) { 函数逻辑(return *this) }`
是使用方法和=正常用法一致
参数要传入引用的原因是避免拷贝的开销，返回值为类型的引用可以保证连续等号的使用，返回自身的引用

关系运算符重载：
实现自定义数据类型的比较，可以在成员函数中实现，如：
`bool operator==(参数&) { 函数逻辑(return true/false) }`
使用方法和==正常用法一致
实现其他关系运算符方法同理

函数调用运算符重载：
即对小括号`()`的重载，重载后使用的方式很像函数调用，因此称为仿函数，仿函数没有固定写法，十分灵活，可以在成员函数中实现，如：
`返回值 operator()(参数) { 函数逻辑 }`
使用方法类似函数（仿函数）
可以利用匿名对象实现匿名函数对象，即先创建一个匿名对象再调用仿函数

### 继承
继承技术可以实现代码复用，基本语法如下：
`class A: public class B { 类内容 }`
引号`:`后的权限指明了继承的方式
继承方式有三种：公共（public）、保护（protected）、私有（private）
public继承会使父类中对应权限（除private外）的成员按原有权限继承到子类中
protected继承会把public权限的成员变成protected
private继承会把public和protected变为private
注意私有属性只是被隐藏了，子类无法访问，但还是继承了
Windows下可以利用vs的开发人员命令提示工具查看对象模型，跳转到对应文件下用命令
`cl /d1 reportSingleClassLayout类名 文件名`  

子类继承后创建对象时，会先调用父类的构造，再用本身的，析构时相反

当子类与父类出现同名成员时，需要区分作用域访问，访问子类时直接访问即可，对父类需要加作用域

菱形继承易出现二义性和冗余的成员，对于二义性可以通过限定作用域的方式加以区分，利用虚继承就可以解决冗余成员问题，在继承方式前加上关键字`virtual`变为虚继承，基类被称为虚基类。虚继承后从类结构模型来看其虚基类会变为一个vbptr（虚基类指针），指向vbtable（虚基类表），虚基类表会说明虚继承的同源成员的偏移量为多少，虚继承后多个同源的成员只剩下一份。简单来说就是将继承数据变成了继承指针

### 多态
多态分为两类
一类是静态多态：函数重载和运算符重载，复用函数名
一类是动态多态：派生类和虚函数实现运行时多态
二者区别在于静态多态的函数地址在编译阶段就已经确定，而动态多态的函数地址在运行阶段确定

动态多态要求：有继承关系，且子类重写父类的虚函数。
动态多态的使用：父类的指针或者引用执行子类对象

虚函数的定义在返回值前加上`virtural`即可，这样子类继承后重写并调用的函数就可以实现地址在运行时绑定
虚函数的本质是一个指针`vfptr`，会指向一个虚函数表`vftable`，其中存放虚函数的地址。子类重写父类的虚函数之后，子类中的虚函数表内容会替换成子类的虚函数地址，而父类的虚函数表不会发生变化。当父类的指针或者引用指向子类对象时，发生多态，调用函数就会走对应子类的虚函数表

通常父类中的虚函数实现是无意义的，因此可以将其改为纯虚函数，语法如下：
`virtual 返回值 函数名(参数) = 0`
当类中有纯虚函数，则该类称为抽象类，抽象类无法实例化对象，并且子类必须重写抽象类中的纯虚函数，否则也属于抽象类

多态使用时，如果子类中有属性开辟到堆区，则父类指针/引用在释放时无法调用到子类的析构代码，因此需要将父类的析构函数写为（纯）虚析构。使用虚析构和使用虚函数方法一致，但是如果使用纯虚析构，因为析构函数是一定会被调用的（先子后父），所以纯虚析构也要有代码实现，写法为在类外声明作用域的情况下完成纯虚析构的函数体。即纯虚析构要有声明也要有实现

### 文件操作
需要头文件`<fstream>`文件类型可以分为两种：文本文件，以ASCII码存储；二进制文件，用01存储
操作文件有三大类：`ofstream`读操作，`ifstream`写操作，`fstream`读写操作

写文件步骤如下：
1. 包含头文件
2. 创建流对象`ofstream ofs`
3. 打开文件`ofs.open("path", mod)`
4. 写入数据`ofs << "data"`
5. 关闭文件`ofs.close()`
常见的打开方式有：
ios::in 			| 		读取打开
ios::out 		|	 	写打开
ios::ate 		| 		打开到文件尾
ios::app		|		追加方式写
ios::trunc	|		若已存在则先删除后创建
ios::binary	|		二进制方式

读文件和写文件步骤类似，还需另外加上判断是否成功打开文件（用is_open()函数，返回bool），读文件有四种方式读取：
1. 用buf数组存储要读出的数据，并利用while循环逐行读出到结束，直接使用`>>`
2. 用ifs中的成员函数`getline(char *buf, int cnt)` ，逐行读取
 3. 用字符串配合全局函数`getline(stream, string buf)`，逐行读取
 4. 用ifs中的成员函数`get()`并且判断是否读到EOF

二进制写文件时需要指定binary模式，并通过流对象调用成员函数write实现`ostream& write(const char *buf, int len)`，字符指针buf指向内存中的一段存储空间，len是读取`字节数`

二进制读文件通过流对象调用成员函数read实现`istream& read(char *buf, int len)`，参数同write
### 模板
基于泛型编程的思想，cpp中有两种模板机制：函数模板和类模板

**函数模板**
函数模板的作用是建立一个通用函数，函数返回值和参数类型可以不具体制定，用一个虚拟类型来代表，语法如下：
```cpp
template<typename T>
函数声明/定义
```
template是声明要创建模板，typename表明其后面的符号是一种数据类型，可以用class替代，T是通用数据类型，名称可以替换，通常为大写字母
有两种方式使用函数模板：自动推导和显示指定
自动推导直接使用即可，编译器会编译时推导T的具体类型
显示指定需要在函数名后加上`<具体类型>`来显示声明T的具体类型是什么
自动类型推导时必须要推导出一致的数据类型T才能使用，模板必须确定出T的数据类型才能使用

普通函数和函数模板的区别：
1. 普通函数调用时可以自动类型转换（隐式）
2. 函数模板调用时，如果用自动类型推导，则不会隐式转换
3. 函数模板用显示指定的方式，可以发生隐式转换

两者的调用规则：
1. 若两者都能使用，优先普通函数
2. 可以通过空模板参数列表（函数名后加`<>`）来强制调用函数模板
3. 函数模板也可以重载
4. 函数模板如果可以更好的匹配，则优先使用

自定义数据类型传入模板时的操作可能会有问题，可以通过具体化优先调用解决，在函数前加`template<>`并声明具体参数的类型及其操作即可 

**类模板**
类模板的声明方式和函数模板相同，在头上一行添加模板的声明即可。类模板的作用是建立一个通用类，类中成员的数据类型可以不具体指定，用一个虚拟类型来代表，如果一个虚拟类型不够用，可以追加定义多个虚拟类型
使用时同函数模板，用模板的参数列表去指定具体类型，但是类模板没有自动推导的方式，因此一定要用模板参数列表显式指定类型。此外，类模板在模板参数列表中可以有默认参数，参数列表缺省时会使用默认参数

普通类中的成员函数一开始就可以创建，而类模板中的成员函数在调用时才创建，也就是说，如果类模板中的某个函数在某个对象中没有被使用到，那么就算当前对象的模板参数和该函数中要求的参数是冲突的也可以正常运行，因为不使用就不会创建，不创建则无冲突
对同一个模板参数的成员函数，和普通类的成员函数一样，各实例是共享的。类模板的成员函数是按需实例化的

类模板对象做函数参数时，有三种传参方式，都是在函数声明时完成：
1. 指定传入类型，通过模板参数列表直接显示对象的数据类型
2. 函数参数模板化，将对象中的参数变为模板参数传递，需要在函数头上一行添加模板声明，并且模板参数要和类模板对应
3. 整个类模板化，将对象类型模板化后传递，也就是把对象类型当作模板，同样需要为函数添加模板声明
方法一其实就是显示指定类模板，而方法二三其实是创建了函数模板，并利用了其自动推导的功能

类模板在继承时要满足：子类继承自类模板父类时，子类声明时要指定父类中T的具体类型，否则编译器无法给子类分配内存。如果想灵活指定父类中T的类型，则子类也要变成类模板

类模板成员函数的类外实现，要在函数头上一行加上模板声明，另外还要在作用域声明的类名后加上类模板的模板参数

**类模板的分文件编写**
与正常的类分文件编写类似，但是由于类模板的成员函数是在调用时创建，会导致分文件在编写时链接不到，因此有两个解决方案：
1. 直接包含源文件（.cpp）
2. 将声明与实现写在同一文件中，文件后缀为（.hpp），后缀非强制 
第二种方式更常用

类模板的友元实现：类内实现和类外实现
类内实现同正常的类写即可，类外实现时在类外会变成函数模板，因此在类模板内部声明友元时需要在函数名后加上一个空模板的参数列表。同时还需要让编译器知道该函数的存在，将该函数放在类模板的上方，同时在该函数的上方还要给出使用类模板的声明
### STL
标准模板库，广义上分为容器、算法和迭代器，容器和算法之间通过迭代器无缝衔接，STL几乎所有代码都采用了模板类和模板函数
STL有六大组件：容器、算法、迭代器、仿函数、适配器、空间配置器
算法要通过迭代器才能访问容器中的元素

**vector动态数组**
用迭代器访问内部数据，`::`操作符来访问容器内的迭代器，`.begin()`函数访问第一个元素，`.end()`函数访问最后一个元素的下一个位置，迭代器其实是一个指针，指向数组中的元素
实现了如下构造函数：空数组（无参），使用已有vector初始化（有参构造、拷贝传入的v的迭代器的左闭右开的元素），n个相同元素数组（有参构造、将n个元素拷贝给本身），和已有vector相同（拷贝构造）

实现了如下赋值操作：
重载`=`运算符，实现已有vector对象赋值
assign成员函数，将传入迭代器左闭右开的数据或者n个相同元素拷贝给自身

实现了如下的容量与大小操作：
empty成员函数，判断是否为空
capacity成员函数，返回容器容量
size成员函数，返回元素个数
resize成员函数，重新指定容器长度，变长会默认填充新位置，变短会删除多余元素，可以指定填充的元素，默认为0

实现了如下的插入与删除：
push_back成员函数，尾插
pop_back成员函数，尾删
insert成员函数，向指定迭代器位置前插入元素，可以插入n个
erase成员函数，可以删除指定迭代器指向的位置，可以给出两个迭代器，会删除之间的所有元素，左闭右开
clear成员函数，删除容器所有元素

实现了如下的存取：
重载`[]`运算符，直接使用下标存取
at成员函数，存取对应下标元素
front成员函数，返回容器中第一个数据元素
back成员函数，返回容器最后一个数据元素

实现了如下的互换功能：
swap成员函数，可以将传入的容器参数和本身元素互换，可以用于收缩内存，利用和匿名对象的交换实现

实现了如下预留空间的功能：
reserve成员函数，为容器预留传入参数个数的长度，预留的位置不初始化，元素不可访问，该功能可以减少vector动态扩容时的扩容次数

**string字符串**
本质上是一个类，内部封装了`char*`，管理这个字符串，是一个`char*`的容器
有四种构造方法：创建空字符串（无参），使用已有字符串初始化（有参构造、参数为传入的字符串），用另一个string对象初始化（拷贝构造、参数为传入对象的引用），用n个字符c初始化（有参构造、参数为数量n和字符c）

实现了如下赋值操作：
重载`=`运算符，能够实现char*字符串、string对象和单个char的赋值；
assign成员函数，可以将某字符串前n个字符、string对象引用、n个char字符赋值

实现了如下拼接功能：
重载`+=`运算符，能够实现在后面拼接char*、char和string对象
append成员函数，能够实现将char*、char*的前n个字符、string对象引用和string对象引用的pos下标开始的n个字符拼接到原对象后

实现了如下的（常用）查找和替换：
find成员函数，能够直接查找string对象中有没有目标字符串，并返回第一次出现位置的下标，没有则返回-1
rfind成员函数，和find一致，但是返回的是最后一次出现的位置下标，和find的区别就是从左往右和从右往左查找的区别
replace成员函数，从指定下标开始，替换指定长度的字符变为指定字符串，下标和长度决定了原字符串消失的部分，指定字符串决定了替换的内容

实现了如下的比较：
compare成员函数，可以与string对象或者char*字符串比较，相等返回0，大于返回1，小于返回-1

实现了如下的存取：
重载`[]`运算符，可以通过下标存取
at成员函数，通过参数n访问对应下标

实现了如下的插入和删除：
insert成员函数，可以在指定下标开始插入char*、string对象引用和n个char字符
erase成员函数，可以删除指定下标开始的n个字符

实现了如下获取字串：
substr成员函数，返回从指定下标开始的指定长度字串

**deque双端队列**
双端队列，允许对头尾两端都进行插入删除操作，和vector的区别在于：vector对头部的插入删除效率低，且数据量越大效率越低，deque相对更快，但是vector的访问元素速度更快，这和两者的实现有关，deque内部有一个中控器，维护每段缓冲区的内容，缓冲区存放真实数据，中控器维护的是每个缓冲区的地址，使得使用deque时就像一片连续的空间
实现了如下的构造函数：默认构造（无参），根据传入的迭代器将迭代器左闭右开区间的元素拷贝给自身（有参），将n个传入的元素值拷贝给自身（有参），根据传入的deque容器引用构造（拷贝）

实现了如下的赋值操作：
重载`=`运算符，能够实现给出的deque对象的拷贝构造赋值
assign成员函数，能够根据传入的迭代器左闭右开的或者n个相同元素赋值

实现了如下的大小操作：
empty成员函数，判断容器是否为空
size成员函数，返回容器中元素个数
resize成员函数，调整容器大小，和vector相同

实现了如下的插入和删除：
和vector一样的push_back和pop_back成员函数
在头部操作的push_front和pop_front成员函数
和vector一样的insert、clear、erase成员函数

实现了如下的数据存储操作：
和vector一样的at成员函数、重载`[]`运算符
front成员函数，返回容器第一个元素
back成员函数，返回容器最后一个元素

**stack栈**
先进后出的数据结构，只有一个出口
实现了如下构造函数：无参构造和拷贝构造
通过push函数入栈、pop函数出栈
通过top函数返回栈顶元素
通过empty、size查看大小

**queue队列**
先进先出的数据结构，有两个出口
实现了如下的构造函数：无参构造和拷贝构造
通过push函数入队、pop函数出队
通过back函数返回最后一个元素、front函数返回第一个元素
通过empty、size查看大小

**list链表**
可以将数据链式存储，在存储单元上非连续，逻辑顺序上通过指针链接实现，STL中的list是一个双向循环链表。由于链表的存储方式不是连续的空间，因此list中的迭代器只支持前移和后移，属于双向迭代器。
list的优点在于动态分配存储，不会造成内存浪费和溢出，且插入和删除十分方便，修改指针即可
list的缺点在于空间和时间额外消费大
list和vector的一个区别在于list插入和删除操作不会造成原有的迭代器的失效，这在vector中不成立
实现了如下的构造函数：无参构造，根据传入的迭代器左闭右开的区间拷贝元素给自身（有参构造），将传入的n个元素拷贝给自身（有参构造），根据已有对象构造（拷贝构造）

实现了如下的赋值和交换：
assign成员函数，将传入迭代器的左闭右开区间数据拷贝给本身或者将传入的n个元素拷贝给自身
重载`=`运算符，根据已有对象赋值
swap成员函数，将传入的list与自身的元素互换

实现了如下的大小操作：
size、empty、resize对大小的访问/操作

实现了如下的插入和删除：
push_back、pop_back在尾部插入和删除元素
push_front、pop_front在头部插入和删除元素
insert、clear、erase等操作
remove成员函数，根据传入的元素删除所有相同的元素

实现了如下的存取：
front成员函数，返回第一个元素
back成员函数，返回最后一个元素

实现了如下的反转和排序：
reverse成员函数，实现了对链表的反转
sort成员函数，实现了对链表的排序，默认小到大。要注意的是，不支持随机访问的迭代器不能直接使用标准sort算法函数（全局），而是要使用自身内部实现的成员函数，可以传入返回bool值的比较函数来指定排序方法

**set/multiset集合**
所有元素在插入时会被自动排序，本质是一个关联式容器，底层使用二叉树实现。set和multiset的区别在于set中没有重复元素，而multiset中允许有。插入数据时，set会返回`pair`容器，内容为`<iterator, bool>`，通过判断返回值的`second`成员属性可以得知是否插入成功
实现了如下的构造函数：无参构造和根据已有对象的拷贝构造

实现了重载`=`运算符的赋值操作

实现了size、empty、swap的大小和交换功能

实现了insert、clear、erase的插入和删除功能，通过迭代器删除

实现了如下的查找和统计：
find成员函数，用于查找，返回迭代器，没找到返回end
count成员函数，统计值为传入参数key的元素个数

`pair`对组
是成对出现的数据，利用该容器可以返回两个数据，创建方式可以通过有参构造（直接指明类型及值）和用make_pair函数指定对值

通过仿函数实现改变排序规则：
默认下set按升序排序，在模板参数列表中的第二个参数添加排序方式，先写一个类并在其中重载`()`运算符，实现自定义的排序，然后在模板参数列表的第二个参数放上这个类名即可
由于set的默认排序功能，如果要在其中存放自定义数据类型，则需要实现上述的排序规则

**map/multimap映射**
所有元素都是pair，pair中第一个元素为键值，第二个元素为实值，所有元素会根据元素的键值自动排序，也是一个关联式容器，底层通过二叉树实现，优点在于可以通过key很快的找到value
map和multimap的区别在于：map中不允许有重复键值，而multimap中允许
实现了如下的构造函数：无参构造和根据已有对象的拷贝构造

实现了`=`运算符重载的赋值操作

实现了size、empty、swap的大小和交换操作

实现了insert、clear、erase的插入和删除操作

实现了find和count的查找和统计功能

map的排序默认为按照key值从小到大排序，要自定义排序需要实现仿函数，方法与set一致

**函数对象**
函数对象就是重载`()`的类，也就是仿函数，其对象通常称为函数对象，本质是一个类，函数对象和普通函数的不同点就在于其可以有自己的状态，并且可以作为参数传递
可以用于向sort函数传递排序规则

**谓词**
返回bool类型的仿函数称为谓词，如果重载`()`接受一个参数则称为一元谓词，如果两个则称为二元谓词

**内建函数对象**
是STL内部实现的一系列函数对象，可以分为算术仿函数、关系仿函数和逻辑仿函数，这些仿函数产生的对象用法和一般函数完全相同，使用时需引入头文件`<functional>`

算术仿函数实现了四则运算，其中negate是一元的，其余为二元，如下：
plus（实现了加法）、minus（实现了减法）、muliplies（乘法）、divides（除法）、modulus（取模）、negate（取反）
使用时需要用模板参数指定运算操作数类型

实现了如下的关系仿函数：
equal_to（等于）、not_equal_to（不等于）、greater（大于）、greater_equal（大于等于）、less（小于）、less_equal（小于等于）
可以用于sort函数中指定排序规则

实现了如下的逻辑仿函数：
logical_and（逻辑与）、logical_or（逻辑或）、logical_not（逻辑非）

**常用算法**
主要由`<algorithm>`、`<fuctional>`、`<numeric>`组成

有以下常用遍历算法：
for_each，遍历容器，可以传入一个函数/仿函数作为参数，会对遍历的每一个元素执行该函数
transform，搬运容器到另一个容器中，接受四个参数，第一个是源容器开始迭代器、第二个是源容器结束迭代器、第三个是目标容器开始迭代器、第四个是函数/仿函数，目标容器需要提前开辟空间（使用resize函数）

有以下常用查找算法：
find，查找元素
find_if，按条件（谓词）查找元素
adjacent_find，查找相邻重复元素，返回相邻元素的第一个位置的迭代器
binary_search，二分查找，返回bool，告诉元素是否存在，在无序序列中不可用
count，统计元素
count_if，按照条件（谓词）统计

有以下常用排序算法：
sort，对容器内元素排序
random_shuffle，洗牌，对指定范围内的元素随机调整顺序
merge，容器元素合并，并存储到另一容器中，两个容器必须有序，最后的结果也是有序的，接受五个参数，第一个是容器1开始迭代器、第二个是容器1结束迭代器、第三个是容器2开始迭代器、第四个是容器2结束迭代器、第五个是目标容器开始迭代器
reverse，反转指定范围内的元素

有以下常用拷贝和替换算法：
copy，拷贝指定范围的元素到另一容器中
replace，将指定范围的元素修改为新元素
replace_if，按照条件（谓词）替换
swap，交换元素

有以下常用的算术生成算法：
accumulate，计算容器元素累计总和，可以设置起始累加值
fill，向容器中指定范围填充元素

有以下常用集合算法：
set_intersection，求两个容器的交集
set_union，求两个容器的并集
set_difference，求两个容器的差集
上述函数都要求容器必须是有序序列，目标容器要提前开辟空间，返回值是运算得到的集合的最后一个元素的迭代器
### 智能指针
智能指针有三种，独占指针unique_ptr，共享指针shared_ptr，和弱指针weak_ptr，都是为了实现RAII，防止内存泄漏，保证内存安全
unique_ptr保证独占式所有权，禁止拷贝但是可以被移动，移动后原指针变为空指针，离开作用域时会自动释放资源
shared_ptr实现共享式所有权，适用于多个对象共享同一资源的情况，当所有指针都销毁后才会释放资源
weak_ptr解决共享指针可能导致的循环引用而使资源无法被释放的情况，只有观察权，没有所有权，不能对指向的对象做任何操作，仅仅是判断资源是否还存在以及获取共享指针引用数，通过lock()方法可以转为一个共享指针来进行操作
### 左值引用与右值引用
左值，简单来说就是可以取地址的值，包括各种变量；右值，就是不能取地址的值，如字面量、常量和临时对象
右值引用就是对右值的引用/别名，但是由于右值引用会给右值一个名字，因此有名字的右值引用本身是一个左值
通过move函数可以将左值转为右值，一般用于转换后再调用移动构造和移动赋值操作，移动比起拷贝开销更低，效率更高
引用折叠是指多重引用下最终得到的引用的结果，规则是含有左值的引用最终都是左值引用，都是右值引用才能得到右值引用
`T &&`是利用引用折叠得到的万能引用（转发引用）的写法，其中T是泛型，根据传入的T会得到不同的引用类别，适用于函数模板的参数自动推导和auto推导，但是不适用于类模板，因为实例化时会确定T的值
通过万能引用可以实现完美转发，即在函数模板中将参数原封不动（左值还是左值、右值还是右值、const还是const）的传递给其他参数，使用forward函数来实现转发，forward函数可以保持左右值属性，但是其模板参数需要推导
### lambda表达式/匿名函数
写法为`[ 捕获列表 ]( 参数列表 ) mutable(可选，是否修改按值捕获的变量) -> 返回类型 { 函数体 }`
捕获列表用于指定lambda表达式可以访问的外部变量及其访问方式（值访问/引用访问），有如下选项：
1. 空列表，表示不访问任何外部变量
2. [=]按值捕获所有外部变量
3. [x]按zhi'bu'huo
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTAyMTcxNzY2NSwtMTIwMTk0MTYzNCw2Mj
IyMDc2NTMsNjYxNTYsLTEzMTEzNjUyMjIsOTAzMjU1MDM1LC0x
ODcwMDUxMDEyLDE3OTI5NTkxODQsLTEzMTIwMjIyMjQsMTU5Mj
YzMzQ5OCwxNDU0OTI1MjEzLC00MzA1NTYzMDYsMTExOTIxNDI2
OSwtNTkyNjk2MjQ5LC00ODMzNzExOSw3MzAzMTQ1MzYsLTE3MT
U3MjUzMjMsMTcxMzIzOTI0MiwtMjEzMTcxMDIwOSwxNTcxMDYz
NV19
-->