# 5.30
## 题目一
### 回文字符串，给定一个字符串，判定需要进行几次插入操作将其变为回文串
#### eg：
```C++
>>>s = 'zzazz'
0
>>>s = 'mbadm'
2
```
出师不利，跳了一题我最不擅长的动态规划，参考题解我们分析得到，从字符串左右两边出发，如果遍历完成就返回0，如果有最优解就返回当前最优解，不然就找到当前插入的最优解，然后记录并返回，得到题解如下：
```c++
class Solution {
public:
	int mem[510][510];
	string s;
	int dp(int start, int end){
		//遍历结束
		if(start >= end){
			return 0;
		}
		//寻找最优解
		//已有最优解
		int ref = mem[start][end];
		if(ref != -1) return ref;
		//没有最优解
		else{
			int left = INT_MAX, right = INT_MAX, match = INT_MAX;
			if(s[start] == s[end]){
				match = dp(start + 1, end - 1);
		}
		else{
			left = dp(start, end - 1) + 1;
			right = dp(start + 1, end) + 1;
		}
		ref = min(left, right);
		ref = min(ref, match);
		mem[start][end] = ref;
		return ref;
		}
	}
	int minInsertions(string S) {
		s = S;
		memset(mem, -1, sizeof(mem));
		int len = s.size();
		return dp(0, len - 1);
	}
};
```
#####  历史未通过说明：
判断结束时应用start>=end而不只是start==end，因为在找最优解的过程中可能出现start>end的情况（match时），此时遍历应该结束，不然可能数组越界

## 题目二



<!--stackedit_data:
eyJoaXN0b3J5IjpbMTgwNzcxMDUzMiwtNjIxNDYzNDAyXX0=
-->