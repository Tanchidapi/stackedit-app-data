# 6.20
## 题目一
### 给定一个数组，一个整数k，问其是否存在一个连续的子数组满足：长度大于等于2且元素和为k的倍数
#### eg：
```c++
>>>nums = [23,2,4,6,7], k = 6
true
```
前缀和问题，可以这样看问题，从数组第一个数开始计算前缀和，并将其放入集合中，第二个数开始判断到当前数为止的前缀和是否在集合中出现过，如果有，说明中间一定存在一个子数组满足条件，没有则加入到前一个数为止的前缀和到集合中，循环结束后返回false。先判断条件再加入前一个数的前缀和是为了保证子数组长度大于等于2，题解如下：
```c++
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        unordered_set<int> hash;
        hash.insert(0);
        int sum = 0, pre = -k;
        for(auto i : nums){
            sum += i;
            sum %= k;
            if(pre != -k){
                if(hash.count(sum)) return true;
                hash.insert(pre);
            }
            pre = sum;
        }
        return false;
    }
};
```
## 题目二
### 给定n个点，表示n个人，这n个人有若干组两人讨厌对方，问能否将这n个人分为两部分，各部分的人都不相互讨厌
#### eg：
```c++
>>>n = 4, dislikes = [[1,2],[1,3],[2,4]]
true
```
二部图的判断，根据图论知识，一个图是二部图的充要条件是图内无奇圈，在算法中可以用着色算法判断，顺序遍历每一个点通过bfs进行着色，如果当前节点未着色，则将其着色并入队，队列非空时循环，考虑其邻点，如果未着色则着相反颜色，然后入队，如果已着色则比较与当前节点的颜色，如果颜色相同说明有奇圈，返回false，所有节点判断完后返回true，题解如下：
```c++
class Solution {
public:
    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {
        if(n == 1) return true;
        vector<vector<int>> g(n + 1);
        for(auto i : dislikes){
            g[i[0]].push_back(i[1]);
            g[i[1]].push_back(i[0]);
        }
        vector<int> color(n + 1, 0);
        queue<int> Q;
        int v, cur;
        for(v = 1; v <= n; v++){
            if(!color[v]){
                color[v] = 1;
                Q.push(v);
                while(!Q.empty()){
                    cur = Q.front();
                    Q.pop();
                    for(auto i : g[cur]){
                        if(!color[i]){
                            color[i] = -color[cur];
                            Q.push(i);
                        }
                        else if(color[i] == color[cur]) return false;
                    }
                }
            }
        }
        return true;
    }
};
```
## 题目三
### 给定一个整数数组和整数k，现可以将k以任意方式整数地分配给数组中的任意一个数，问分配完后同样数字的最大数量是多少
#### eg：
```c++
>>>nums = [1,2,4], k = 5
3
```
滑动窗口题型，先对数组升序排序，pre为移动前分配成的值，cur为移动后分配成的值，rest记录还剩多少值可以用，从第一个数开始，然后开始移动滑动窗口的右指针，如果当前数和pre一样，说明不用分配值，记录最长的子数组长度（个数）为max（右指针-左指针+1，yi'ji'lu
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTk5Mzc4ODU5MSwtMTA1NjkyNDgyOSwtMT
YxODA3MTA0MywtMTg3NzAyNjg5OF19
-->