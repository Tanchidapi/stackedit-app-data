# 6.20
## 题目一
### 给定一个数组，一个整数k，问其是否存在一个连续的子数组满足：长度大于等于2且元素和为k的倍数
#### eg：
```c++
>>>nums = [23,2,4,6,7], k = 6
true
```
前缀和问题，可以这样看问题，从数组第一个数开始计算前缀和，并将其放入集合中，第二个数开始判断到当前数为止的前缀和是否在集合中出现过，如果有，说明中间一定存在一个子数组满足条件，没有则加入到前一个数为止的前缀和到集合中，循环结束后返回false。先判断条件再加入前一个数的前缀和是为了保证子数组长度大于等于2，题解如下：
```c++
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        unordered_set<int> hash;
        hash.insert(0);
        int sum = 0, pre = -k;
        for(auto i : nums){
            sum += i;
            sum %= k;
            if(pre != -k){
                if(hash.count(sum)) return true;
                hash.insert(pre);
            }
            pre = sum;
        }
        return false;
    }
};
```
## 题目二
### 给定n个点，表示n个人，这n个人有若干组两人讨厌对方，问能否将这n个人分为两部分，各部分的人都不相互讨厌
#### eg：
```c++
>>>n = 4, dislikes = [[1,2],[1,3],[2,4]]
true
```
二部图的判断，根据图论知识，一个图是二部图的充要条件是图内无奇圈，在算法中可以用着色算法判断，顺序遍历每一个点通过bfs进行着色，如果当前节点未着色，则将其着色并入队，队列非空时循环，考虑其邻点，如果未着色则着相反颜色，然后入队，如果已着色则比较与当前节点的颜色，如果颜色相同说明有ji'quan
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE4MjIyMDY0OTAsLTE2MTgwNzEwNDMsLT
E4NzcwMjY4OThdfQ==
-->