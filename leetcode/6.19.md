# 6.19
## 题目一
### 给定一棵树，终点为节点0，其余n - 1个节点都有一个人要前往终点，每个节点有一辆seats个位置的车，每条边要耗费车1升油，每到达一个节点可以拼车或换乘，问到达终点的最少耗油是多少
#### eg：
```c++
>>>roads = [[0,1],[0,2],[0,3]], seats = 5
3
```
dfs解决，创建dfs函数，输入为函数自身（用于递归），当前节点，前驱节点，返回值为从当前节点出发的车辆数，总人数，已耗费油数
函数内先统计当前节点的所有邻点，如果是前驱节点则跳过，否则递归调用自身，将邻点作为递归的当前节点，当前节点作为前驱节点，记录返回值，统计累加所有返回值的总人数和油耗，邻点到自身的油耗为邻点出发的车辆数，故油耗除了邻点已有油耗还要加上车辆数，然后在总人数基础上加一，计算返回当前节点出发的车辆数，总人数，油耗，注意车辆数向上取整
```c++
class Solution {
public:
    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {
        int n = roads.size() + 1;
        vector<vector<int>> edge(n);
        for(auto road : roads){
            edge[road[0]].push_back(road[1]);
            edge[road[1]].push_back(road[0]);
        }
        auto dfs = [&](auto self, int cur, int pre) -> tuple<int, int, long long>{
            int people = 0;
            long long res = 0;
            for(int neighbor : edge[cur]){
                if(neighbor != pre){
                    auto [cars, numbers, cost] = self(self, neighbor, cur);
                    people += numbers, res += cost + cars;
                }
            }
            people += 1;
            return make_tuple((people + seats - 1)/seats, people, res);
        };
        return get<2>(dfs(dfs, 0, -1));
    }
};
```
## 题目er
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1ODgzNjcyOTYsLTE4MzM5NTk1NDhdfQ
==
-->