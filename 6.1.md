# 6.1
## 题目一
### 验证图书的存取顺序，给定一个图书存入的顺序和取出的顺序，判定能否合法取出
#### eg：
```c++
>>>putIn = [6,7,8,9,10,11], takeOut = [9,11,10,8,7,6]
true
```
题目本质上是一个栈的模拟，看以给定的顺序能否正常出栈入栈，题解如下：
```c++
class Solution {
public:
	int top = -1;
	int s[1005];
	bool validateBookSequences(vector<int>& putIn, vector<int>& takeOut) {
		int pin = 0, pout = 0;
		int len = putIn.size();
		if(len == 0) return true;
		while(1){
			s[++top] = putIn[pin];
			pin++;
			while(top >= 0 && pout < len && s[top] == takeOut[pout]){
				top--;
				pout++;
			}
			if(pin == len && top == -1) return true;
			if(pin == len && top >= 0) return false;
		}
	}
};
```
##### 历史未通过说明
1. 开始时忘记加外循环退出判定条件了，导致死循环内存泄漏
2. 第二次发现内循环可能数组越界，加入判断条件
## 题目二
### 替换链表指定下标范围内的节点，给定两个链表，下标a，b，将链表1下标a，b部分替换为链表2
#### eg：
![输入图片说明](/imgs/2025-06-01/X734cCIUlzKHzOFC.png)示意图
链表的替换典型题目，但提交后发现时间和空间排名只有60%左右，看参考题解找不出区别，时间复杂度O(n)，空间O(1)，如下：
```c++
class Solution {
public:
	ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {
		int tag = 0;
		ListNode *pa = list1, *pb = list1, *ped = list2;
		for(; tag < a - 1; tag++){
			pa = pa -> next;
		}
		for(tag = 0; tag <= b; tag++){
			pb = pb -> next;
		}
		pa -> next = list2;
		for(; ped -> next != nullptr;){
			ped = ped -> next;
		}
		ped -> next = pb;
		return list1;
	}
};
```
## 题目三
### 

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTY2Njc4NjU5OSwtNzUyOTkzMDI5LDE5OT
czMTE1NjgsMjEwNzk2MzIxXX0=
-->