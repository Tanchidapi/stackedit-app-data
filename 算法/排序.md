# 排序
## 1.插入排序
### 1.1直接插入排序
依次将每个元素插入到前面有序的部分，时间复杂度O(n^2)，为稳定排序
```c++
template <typename T>
void insertionSort(vector<T>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; i++) {
        T key = arr[i]; // 当前待插入元素
        int j = i - 1;  // 从当前元素的前一个开始比较
        
        // 将比key大的元素向后移动
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        // 插入元素到正确位置
        arr[j + 1] = key;
    }
}
```
### 1.2折半插入排序
依次将每个元素插入到前面有序的部分，不过查找插入位置的方式变为折半查找，找到插入位置后在统一后移插入，时间复杂度为O(n^2)，稳定排序
```c++
template <typename T, typename Compare = less<T>>
void binaryInsertionSort(vector<T>& arr, Compare comp = Compare()) {
    int n = arr.size();
    
    for (int i = 1; i < n; i++) {
        T key = arr[i];
        int left = 0;
        int right = i - 1;
        
        // 二分查找插入位置
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (comp(key, arr[mid])) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        // 移动元素
        for (int j = i - 1; j >= left; j--) {
            arr[j + 1] = arr[j];
        }
        
        // 插入元素
        arr[left] = key;
    }
}
```
### 1.3表插入排序
类似于单链表的结构，每个节点按顺序指向下一个节点，时间复杂度为O(n^2)，为稳定排序
```c++
// 插入节点到有序链表
void sortedInsert(shared_ptr<ListNode<T>>& sortedHead, shared_ptr<ListNode<T>> newNode) {
    // 如果链表为空或新节点应插入头部
    if (!sortedHead || newNode->data <= sortedHead->data) {
        newNode->next = sortedHead;
        sortedHead = newNode;
    } else {
        // 查找插入位置
        auto current = sortedHead;
        while (current->next && current->next->data < newNode->data) {
            current = current->next;
        }
        // 插入新节点
        newNode->next = current->next;
        current->next = newNode;
    }
}

// 执行表插入排序
void sort() {
    if (!head || !head->next) return;
    
    shared_ptr<ListNode<T>> sortedHead = nullptr;
    auto current = head;
    
    while (current) {
        auto nextNode = current->next;
        sortedInsert(sortedHead, current);
        current = nextNode;
    }
    
    head = sortedHead;
}
```
### 1.4希尔排序
设定初始增量d=n/2，以增量为单位进行排序，每次增量除以2，增量为1时为最后一趟排序结束，时间复杂度在O(n ^ 1.3)~O(n ^ 1.5)不等，为不稳定排序
```c++
```
## 2.快速排序
### 2.1冒泡排序
相邻两两不停比较，大的往后移，比较至最后一个元素结束一趟，共进行n-1趟，时间复杂度为O(n^2)，为稳定排序
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTk4ODQzMzMyNCwyNjU2NjcyNDAsNjAzND
YxNzYwLDQ4NTA2NjU4NywxODc3MDgwN119
-->