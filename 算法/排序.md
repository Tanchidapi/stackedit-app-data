# 排序
## 1.插入排序
### 1.1直接插入排序
依次将每个元素插入到前面有序的部分，时间复杂度O(n^2)，为稳定排序
```c++
template <typename T>
void insertionSort(vector<T>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; i++) {
        T key = arr[i]; // 当前待插入元素
        int j = i - 1;  // 从当前元素的前一个开始比较
        
        // 将比key大的元素向后移动
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        // 插入元素到正确位置
        arr[j + 1] = key;
    }
}
```
### 1.2折半插入排序
依次将每个元素插入到前面有序的部分，不过查找插入位置的方式变为折半查找，找到插入位置后在统一后移插入，时间复杂度为O(n^2)，稳定排序
```c++
template <typename T, typename Compare = less<T>>
void binaryInsertionSort(vector<T>& arr, Compare comp = Compare()) {
    int n = arr.size();
    
    for (int i = 1; i < n; i++) {
        T key = arr[i];
        int left = 0;
        int right = i - 1;
        
        // 二分查找插入位置
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (comp(key, arr[mid])) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        // 移动元素
        for (int j = i - 1; j >= left; j--) {
            arr[j + 1] = arr[j];
        }
        
        // 插入元素
        arr[left] = key;
    }
}
```
### 1.3表插入排序

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTc5MjcxOTAwOSwyNjU2NjcyNDAsNjAzND
YxNzYwLDQ4NTA2NjU4NywxODc3MDgwN119
-->