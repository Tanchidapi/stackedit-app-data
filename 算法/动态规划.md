# 动态规划
## 动态规划原理
本质上是分治递归+记忆存储，即有记忆的递归，用于减少计算重复部分的时间，因此适用范围也是子问题有关联重复的情况，动态规划主要分为四步：
1. 分析优化解的结构
2. 递归定义最优值
3. ****自底向上****求解最优值，保存并记录构造信息
4. 根据信息构造最优解
## 1.矩阵乘法
一系列矩阵相乘可以利用矩阵的结合律简化计算总次数，通过将其分为不同给部分递归的求解，每次选出所有划分情况中的最小值，时间复杂度为O(n^3)

![输入图片说明](/imgs/2025-06-14/oIeahBNQAZRnxJUr.png)![输入图片说明](/imgs/2025-06-14/EmAGqeozfPFJDekX.png)
递归方程
![输入图片说明](/imgs/2025-06-14/8ghJ2ZdRxZ8CA3GY.png)
伪代码
![输入图片说明](/imgs/2025-06-14/nps3PS72bKdQZmLj.png)示意图
## 2.最长公共子序列问题（LCS）
从后往前分别观察两个序列，如果最后一个字符相同，则LCS为最后一个字符加上这两个序列去掉最后一个字符后的LCS，否则的话为其中一个序列去掉最后一个字符后继续与另一个序列求LCS的最大值，时间复杂度为O(mn)

![输入图片说明](/imgs/2025-06-14/gGEXRdn4LlXUCYJc.png)递归方程
![输入图片说明](/imgs/2025-06-14/8Tjov65cqr7vJpoO.png)伪代码
![输入图片说明](/imgs/2025-06-14/mGNYLIsRJeDr3u1u.png)示意图
## 3.01背包问题
对于一个物品，只有拿和不拿两种可能，并且每样物品只有一个，则可以离散的考虑所有的背包容量的情况，然后对每一样物品选择拿或不拿，若不拿则价值为同容量下拿到前一个物品的最大值，拿的话则为当前物品价值加上容量减去当前物品情况下拿到前一个物品的最大值，两者再取最值即可，时间复杂度为O(mn)

![输入图片说明](/imgs/2025-06-14/7K4vjz3CK15WPUGs.png)递归方程
![输入图片说明](/imgs/2025-06-14/wyRQdXfp1Iqr3xzZ.png)伪代码
![输入图片说明](/imgs/2025-06-14/I2aT2V6DBfBJ7PMD.png)需要给出优化解时的伪代码
![输入图片说明](/imgs/2025-06-14/Rg4YQ5kiflFHWSFh.png)示意图
## 4.完全背包问题
与01背包问题类似，区别就在于每一样物品可以无限的拿，因此递归方程对于拿的情况改为考虑在已拿该物品的情况下，再拿该物品的值，时间复杂度为O(mn)

![输入图片说明](/imgs/2025-06-14/7IYB8rleqrnmOTpZ.png)递归方程
![输入图片说明](/imgs/2025-06-14/XwJUQ44Tv4Run51X.png)一维优化递归方程
![输入图片说明](/imgs/2025-06-14/6eWD728kv2xNmAUn.png)伪代码
示意图与01背包类似
## 最优二叉搜索树
给出一系列节点，按二叉搜索树的形式进行构建结构，同时给出每个节点访问的概率，在给出的概率下构建搜索花费最小的二叉搜索树。考虑以节点k为根，则左侧是最小i到k-1的子树，右侧是k+1到最大j的子树，两个子树的搜索代价加上i到j的搜索代价即是以k为根的搜索代价，遍历所有构造情况即可得出解，时间复杂度为O()

![输入图片说明](/imgs/2025-06-14/58tnu4lXwRVgtvAp.png)概率分布示意图![输入图片说明](/imgs/2025-06-14/Sfs4FFuSiqc7V07L.png)递归方程
![输入图片说明](/imgs/2025-06-14/4eBAqHytaWFWhONc.png)伪代码
![输入图片说明](/imgs/2025-06-14/MHwgLPdxmq8QH6Dy.png)示意图


<!--stackedit_data:
eyJoaXN0b3J5IjpbMTI4MDEyNTg1LDE1MDY3NTM2NDRdfQ==
-->