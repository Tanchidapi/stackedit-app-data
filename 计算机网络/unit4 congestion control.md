## 拥塞基本定义
### 拥塞的情况
![输入图片说明](/imgs/2025-09-18/BBudinJn2s2Lz8Eg.png)总结
拥塞是不可避免的，流量控制是解决拥塞的关键
### 公平性有利于设计拥塞控制
![输入图片说明](/imgs/2025-09-18/Dphl7bM1AsV9ma65.png)示意图

方案一保证了吞吐量，但是方案二在第二条链路上保证了公平性，设计拥塞时要提前达成公平性

![输入图片说明](/imgs/2025-09-18/7uSqvVPRANRCjw1L.png)常用的公平方法——最大最小原则

简单来说就是将最大流最小化，即不能通过减小一个小流的速率来增大一个比他大的流的速率，本质上为共享一个链路的瓶颈，上述情况的方案二就是在最大最小原则下的速率分配情况

![输入图片说明](/imgs/2025-09-18/oyHfz87EVB0Hbnda.png)以单链路为例的一个分配例子

先根据输入链路数量与输出链路速率平均分配，然后从速率最小的输入链路开始，如果其速率小于分配速率，则只分配给其对应的速率，剩下的速率再平分给剩下的链路，然后再考虑次小，如果超过了分配的速率，则只分配给其平均速率，以此类推

### 阻塞控制的目标
1. 实现高吞吐量
2. 实现公平性，通过最大最小原则实现
3. 实现对网络情况的快速反应
4. 实现分布式控制

## 拥塞控制基本方法

### 基于网络的流量控制
需要注意的一点是之前提到过的（加权）公平队列确实可以控制每个链路对应的发送速率，但是不能反馈到输入链路的源以控制他们该以什么速率来发送数据，因此实现拥塞控制时需要来自路由器的显示反馈用于指示网络中的拥塞。通常可以将网络中拥塞的情况如输出链路的剩余流量大小、丢包情况等，通过搭乘要到达某一端点的包来反馈到该端点，端主机可以自由的决定如何处理网络中存在拥塞的情况，如减小流量、实行最大最小公平性等
![输入图片说明](/imgs/2025-09-18/lXjFm32AtS0C8wXv.png)示意图

### 基于端主机的流量控制
设想为通过观察网络的行为，由此来决定发送数据的速率。这一方法的优势在于如果不依赖于路由器的行为，或者不依赖于路由器发送回特定的消息，则端主机可以在不更改网络的情况下随着时间的推移而演化和适应它。一个实际的例子就是TCP，它通过观察网路的行为，完全在端主机上实现拥塞控制。如果一个包丢失了，则端主机可以通过超时或者看到一系列相同的确认信息来判断，从而减小速率来控制拥塞。TCP之所以采取这种方式的还有一个原因是IP本身不提供网络中拥塞情况的反馈，TCP是在IP基础上的，因此采用基于端主机的方式来进行流量控制

![输入图片说明](/imgs/2025-09-18/sQSkXkcJpX3SqLwg.png)示意图

![输入图片说明](/imgs/2025-09-18/OxrrvuNpKxUVhk4h.png)TCP控制概述

![输入图片说明](/imgs/2025-09-18/wy0c0UGYraJvSKSx.png)图中展示的两种情况，一是往返时间大于窗口大小的情况，二是往返时间等于窗口大小的情况，第二种情况下对网络的利用效率更高

![输入图片说明](/imgs/2025-09-18/3Wa5R2qx5uRBgnEj.png)TCP协议会在发送方考虑滑动窗口的大小，在网络通畅时，会用接收端反馈的窗口大小，而在网络拥塞时，则会在发送端计算cwnd的大小，将其作为窗口大小

![输入图片说明](/imgs/2025-09-18/FlVfQjMPgAzpcyKv.png)计算cwnd的方法为AIMD，即线性增大、乘性减小，每有一个包顺利收到则cwnd大小增加窗口大小的倒数，否则若丢包则将窗口大小减半，因此若一窗口顺利发送则会为窗口增加1的大小（W个包），否则就将窗口大小减半。下图是示意图，这一曲线也被称作TCP（AIMD）锯齿波，绿色的曲线是放大后的图像，实际上是每过一个RTT（包确认往返时间）cwnd才增大1

![输入图片说明](/imgs/2025-09-18/THvsV0IXLn0onPA5.png)Summary

## 单数据流中的AIMD控制
![输入图片说明](/imgs/2025-09-18/kCrWW4HVDh242WGQ.png)示意图
在缓冲区放不下输入链路来的数据包后，会出现丢包，并将该标记附加在缓冲区队列中的最后一个包，等该包到达目的地后目的地会返回丢包信号，发送端收到该信号后就会按照AIMD减小一半的窗口大小，同时停止发送，停止发送与恢复的情况如下图

![输入图片说明](/imgs/2025-09-18/RzpOVbn3pXKLVoch.png)两种方法发送端来判断是否丢包，并做出不同的处理

![输入图片说明](/imgs/2025-09-18/pGflQrtdiZ6vovu5.png)示意图三张图有四张曲线，分别表示了cwnd的大小、往返时间（由于有包在缓冲区中而变大）、瓶颈链路利用率、缓冲区占用率
由图可以看出在AIMD的作用下链路始终保持繁忙，提高了利用效率

![输入图片说明](/imgs/2025-09-18/2CmyEISRX8kOFyGa.png)单流下的速率计算，可以简单的定义为一个窗口所发送出的字节数除以往返时间，因此其实最终结果是一个常数，窗口本质上做的就是探索袋子有多大，我们可以将多少字节放入网络而不溢出

![输入图片说明](/imgs/2025-09-18/TZgmALuVWJGJFbct.png)关于缓冲区的大小，最理想的情况是其大小等于往返时间乘上链路输出的速率，如果小于该大小，则会导致在发生减半后的一小段时间内链路的利用率降低

### 示例
![输入图片说明](/imgs/2025-09-18/WrlvUS8S7f09mB2M.png)![输入图片说明](/imgs/2025-09-18/GMQHddXR58P1pA4S.png)![输入图片说明](/imgs/2025-09-18/E6hKEnx1cyOn3UoO.png)![输入图片说明](/imgs/2025-09-18/vW35pxbeFdIC3Rzz.png)![输入图片说明](/imgs/2025-09-18/8UzY5VPi5fg3Y9ub.png)![输入图片说明](/imgs/2025-09-18/mesBl1QlcW74Vg2I.png)最后一题的答案提示了我们在出现丢包后AIMD需要长时间来恢复到缓冲区的最大利用率的情况，因此还需对此方法做出修改
## 多流数据下的AIMD控制
AIMD并不是控制发送速率，实际上，AIMD控制的是网络中未确认数据包的数量，即那些已发出但还没收到确认的数据包，当网络为空且没有阻塞时，它有空间让一个流发送更多的包，并在网络中拥有更多未确认包，但当网络发生拥塞、充满了数据包时，我们必须减少流中未确认数据包的数量以防止溢出

![输入图片说明](/imgs/2025-09-20/qCEMWi56ZFCiGS7O.png)多流情况下，缓冲区里的数据包来自各个流

![输入图片说明](/imgs/2025-09-20/Th6n43U5wfeKVnI7.png)
当存在多个流时，将RTT（往返时间）视为基本恒定的想法是合理的，因为多流下的缓冲区几乎总是拥塞的，但是单流情况下RTT会随着缓冲区的情况而变化，因此其锯齿波在上升时呈现一定弧度，每一个窗口的完整发送所用的往返时间随着缓冲区内包的增多而变大，因此计算多流下的平均吞吐率可以用平均窗口大小除以RTT

![输入图片说明](/imgs/2025-09-20/cCfv5wq1Xg4ZYeBy.png)吞吐率与丢包概率的关系，以几何的形式推导，注意图中阴影面积的A指的是在一个周期内发送的总的字节数，是发送的窗口个数对各个窗口大小的一个累积，故A的表达式中不含RTT项，最终将速率写成和丢包概率有关的函数，RTT为已知量

![输入图片说明](/imgs/2025-09-20/OdQqEPfS9l4lOhBe.png)第一点含义为在AIMD下我们会惩罚更远的链路速率，但这不是我们想要的，因此这一点通常被认为是AIMD的缺点
第二点指出了丢包是AIMD中控制的关键，它告诉发送方网络中存在太多未确认的包，从而指导发送方控制窗口大小，进而控制拥塞

![输入图片说明](/imgs/2025-09-20/gObFQOzFVvMioC7E.png)Summary

## TCP Tahoe
### 旧的TCP方案
![输入图片说明](/imgs/2025-09-20/Ec2W2NqqprenZDVa.png)在流量控制出现前，TCP总是直接将可用窗口大小的数据量一次性发送，即发送方在建立连接后，会一口气将接收方声明窗口大小的数据包全部注入网络中，这种方法被称为流量启动

![输入图片说明](/imgs/2025-09-20/t0gfTwulSgf9yeg6.png)早期没有拥塞控制下的TCP，因大量的丢包或超时的重传而导致没有预期中的吞吐率

![输入图片说明](/imgs/2025-09-20/eOi7hSod6d6YDZrS.png)三个改进方案分别为拥塞窗口控制，更好的超时估计和自时钟

### 拥塞窗口控制
前文提到的AIMD就是拥塞窗口控制的一个基本思想

![输入图片说明](/imgs/2025-09-20/sghH86HPANxauX7f.png)控制窗口只取决于端主机，大小为流量窗口与拥塞窗口中的最小值，因为在网络有限的情况下超越网络流量窗口大小发送接收方不一定接受的了，而拥塞的情况下发出再大的包也无意义，而拥塞窗口的大小可以分为两种情况：
1. 慢启动，用于重连和数据包超时的情况
2. 拥塞避免，用于接近网络容量拥塞时使用
### 慢启动
慢启动的慢其实是相对于旧版TCP的流量启动而言的，事实上，慢启动的总体过程中，发送数据包的大小与时间呈指数关系，并不慢
慢启动是一种试探性增长的过程，一开始，将窗口大小的起点设置为一个较小的值，每收到一个ack窗口才增加一个MSS

![输入图片说明](/imgs/2025-09-21/BuDhjaWUVrxFNb08.png)慢启动的好处
### 拥塞避免
![输入图片说明](/imgs/2025-09-21/YPbrjuAHr9sL5sWJ.png)拥塞避免与慢启动的区别，拥塞避免是在每收到一个ack确认，发送窗口就增加MSS平方除以拥塞窗口大小的大小，实际上是随着往返时间RTT的一个线性增长

### 两种状态的切换
![输入图片说明](/imgs/2025-09-21/RD4G2HCo3HLjCzyV.png)慢启动和拥塞避免两种状态的切换情况

![输入图片说明](/imgs/2025-09-21/QETey1xyrZ3C2B7h.png)TCP Tahoe的有限状态机，在慢启动和拥塞避免之间切换状态，ssthresh为慢启动的阈值，慢启动在窗口大小指数增长到阈值后切换到拥塞避免，然后变为线性增长，在出现超时或者三次重复的ack出现后将cwnd降至1，并将ssthresh改为原先cwnd大小的一半，再次开始慢启动

![输入图片说明](/imgs/2025-09-21/CvCxngXeTVzK8qB1.png)示意图

### 更准确的RTT估计
![输入图片说明](/imgs/2025-09-21/dpLCwrGNHvPTlWTK.png)RTT估计的重要性

![输入图片说明](/imgs/2025-09-21/3MgcRZB89T3v9VQc.png)Tahoe前的RTT估计方式，问题在于估计值r的值没有反应RTT的分布情况，当包的RTT分布情况较密集时（图中a的情况），β为2的估计过于保守，这会导致RTT估计过大，而包的RTT分布较广泛时（图中b曲线、蓝色），β为2的估计过于激进，会导致RTT估计过小

![输入图片说明](/imgs/2025-09-21/Sq8bPeuWFGTGkntN.png)Tahoe通过引入RTT方差的概念来解决这一问题，通过将偏差也平滑之后再进行超时计算，v体现了网络的波动程度，网络波动越大，超时时间估计的越保守

### 自时钟
![输入图片说明](/imgs/2025-10-04/WiR0qrCo8t42x9RH.png)自时钟模型，上图模型展示了发送端和接收端都有一个较大的缓冲区，但是受到链路瓶颈的限制，发送的时间会被拉长，接收端受到后有变回原样，但是由于传输过程中的时间被拉长了，故接收端两个包之间会有时间间隔，发送回的ack也有间隔，同时因为ack的体积更小，会使得链路中有大量的空闲，发送端收到的ack频率也远小于发送频率，而发送端就会根据收到的ack速率调整自己发送数据的速率，这样数据包就可以根据正确的速率进入链路。简单来说，ack除了充当确认信号外，还起到了作为时钟的作用

![输入图片说明](/imgs/2025-10-04/wBlqTY9SaDaYLr2X.png)自时钟原则

### 三大机制总结
![输入图片说明](/imgs/2025-10-04/j08f3wBvLeLKhMHc.png)总的来说，拥塞窗口/慢启动、超时估计、自时钟三个机制是TCP Tahoe的核心基础

## TCP Reno / TCP NewReno
TCP Tahoe的进一步改进，在保证正确性的前提下提高了性能。简单来说，Tahoe在慢启动时指数增长，超时时将窗口阈值改为当前值一半，然后窗口大小改为1，再次慢启动，到达阈值时变为线性增长，直到遇到超时。
![输入图片说明](/imgs/2025-10-20/B1uizAnXH4KYbBm9.png)Tahoe示意图

Reno和Tahoe的区别在于收到三个重复ACK时的行为不同，不再将窗口大小降到1进入慢启动，而是将大小设置为一半，称其为快速恢复，同时不等待三个ACK的超时，而是直接马上重传

![输入图片说明](/imgs/2025-10-20/73Lai2LEd1OLa6SN.png)Reno特点

![输入图片说明](/imgs/2025-10-20/XrZ4zg6R4gHw5EJx.png)Reno示意图
窗口大小降低后的不变的区间是在进行快速重传，遇到超时时和Tahoe的行为相同，进入慢启动在对数时间内回到阈值

### NewReno
NR在超时方面仍然和Tahoe相同，在收到三个重复ACK时也和Reno一样进行快速重传，但是在快速重传时会有一些精妙的操作，NR在每收到一个重复的ACK就会扩展一个窗口，因为其认为能收到ACK，说明数据包正在成功到达接收方，但是不能发送太快，因为出现了重复的ACK，正在接近网络的拥塞点。（当Reno执行快速重传时，必须等待一个完整的RTT才能发送新数据包，NewReno充分的利用了这一空窗期）随后当收到正确的确认时，将窗口大小缩减到正确的大小，因此不会出现突然饱和网络的情况

![输入图片说明](/imgs/2025-10-20/xGS9TLwXO0lcSSoQ.png)NewReno的特点

![输入图片说明](/imgs/2025-10-20/8o2IPDpMpKKxSywF.png)总结
下面是ds给出的总结，与课程所讲解的略有不同，区别在于Reno发生快重传时cwnd改为原大小+3，New Reno退出快重传的条件为收到恢复应答，即确认全部的丢包情况都已解决，用于处理多丢包情况。
```
### 核心共同点

在讨论区别之前，首先要了解它们共享的基础机制，这是TCP拥塞控制的基石：

1.  **慢启动（Slow Start）**：连接开始时或超时后，拥塞窗口（cwnd）从1个MSS开始，每收到一个ACK就翻倍（指数增长），旨在快速探测可用带宽。
2.  **拥塞避免（Congestion Avoidance）**：当cwnd达到慢启动阈值（ssthresh）后，进入拥塞避免阶段，cwnd每个RTT只增加1个MSS（线性增长），趋于稳定。
3.  **快速重传（Fast Retransmit）**：当发送方收到3个重复的ACK时，它推断有数据包丢失（而非网络严重拥塞），会立即重传对方所要求的那个数据包，而不必等待超时计时器。

**它们的关键区别在于“快速重传”之后做了什么，即“快速恢复（Fast Recovery）”阶段的行为。**

---

### 1. TCP Tahoe

Tahoe是较早的版本，它的逻辑相对简单粗暴。

*   **行为**：
    1.  发生**超时**或收到**3个重复ACK**时，都视为拥塞。
    2.  立即将 `ssthresh` 设置为当前 `cwnd` 的一半（至少为2个MSS）：`ssthresh = cwnd / 2`
    3.  然后将 `cwnd` **重置为 1个MSS**。
    4.  重新开始**慢启动**过程，直到cwnd增长到新的ssthresh，再进入拥塞避免。

*   **优点**：实现简单，对拥塞反应强烈，能迅速缓解网络压力。
*   **缺点**：**过于保守**。即使在只有单个包丢失（通过重复ACK感知）的情况下，它也会将窗口骤降至1，导致网络吞吐量急剧下降，无法有效利用带宽。

**简而言之：Tahoe把任何拥塞信号（超时或重复ACK）都一视同仁，直接打回慢启动原点。**

---

### 2. TCP Reno

Reno在Tahoe的基础上引入了 **“快速恢复（Fast Recovery）”** 算法，这是最关键的改进。

*   **行为**：
    1.  **发生超时**：行为与Tahoe完全一样 -> `cwnd = 1`，进入慢启动。
    2.  **收到3个重复ACK（快速重传）**：
        *   将 `ssthresh` 设置为当前 `cwnd` 的一半：`ssthresh = cwnd / 2`
        *   **关键区别**：并不将 `cwnd` 重置为1。而是将 `cwnd` 设置为 `ssthresh + 3个MSS`（因为3个重复ACK意味着有3个数据包已经离开网络到达了接收方）。
        *   然后进入**快速恢复**阶段。
            *   在快速恢复阶段，每收到一个**重复的ACK**，就稍微增大一点cwnd（因为认为又有一个包离开了网络）。
            *   当收到一个**对新数据的ACK**（即确认了之前所有丢失和未确认的数据）时，退出快速恢复阶段，将 `cwnd` 设置为 `ssthresh`，然后进入**拥塞避免**阶段。

*   **优点**：在发生**单个数据包丢失**时，避免了Tahoe那样从1开始的慢启动，能够保持较高的吞吐量。这是巨大的进步。
*   **缺点**：**无法有效处理同一窗口内的多个数据包丢失**。如果同一个发送窗口内丢失了多个包，Reno在快速恢复阶段可能只能重传其中一个（通过重复ACK触发的那个）。当收到对新数据的ACK退出快速恢复时，可能还有其他丢失的包未被处理，最终只能等待**超时**。一旦超时，cwnd又会被重置为1，性能损失很大。

**简而言之：Reno能优雅处理单个丢包，但多个丢包会导致性能劣化。**

---

### 3. TCP NewReno

NewReno是对Reno的主要改进，旨在解决Rino在**多个数据包丢失**时性能不佳的问题。

*   **行为**：
    *   在**快速恢复**阶段，Reno在收到一个对新数据的ACK后就退出。而NewReno增加了一个 **“部分确认（Partial ACK）”** 的概念。
    *   **部分确认**：在快速恢复阶段，如果一个ACK确认了部分但不是全部从进入快速恢复时开始未被确认的数据，那么它就是一个“部分确认”。这通常意味着又有一个之前丢失的包被重传并收到了。
    *   **NewReno的处理方式**：
        1.  当收到一个部分确认时，NewReno会推断出又有一个包丢失了，于是立即**重传这个部分确认所指向的下一个数据包**。
        2.  同时，将cwnd相应地减小（通常会减去已确认的数据量再加上一个MSS，以补偿重传）。
        3.  它**不会退出快速恢复阶段**，而是继续保持在这个阶段，等待下一个ACK。
        4.  只有当收到一个确认了**进入快速恢复时所有未确认数据**的ACK（称为“完全ACK”）时，它才会退出快速恢复，将cwnd设置为ssthresh，进入拥塞避免。

*   **优点**：**能够在一个RTT内恢复多个数据包的丢失**，极大地减少了因多个丢包而引发超时的可能性，从而提升了吞吐量。
*   **缺点**：仍然是一个基于“丢包”的拥塞控制算法。在高速或长延迟网络中，表现不如后续的BBR等基于延迟的算法。但它比Reno强大得多。

**简而言之：NewReno通过“部分确认”机制，延长了快速恢复阶段，从而能够高效地处理同一窗口内的多个丢包。**

---
```
### 总结对比表格

| 特性 | TCP Tahoe | TCP Reno | TCP NewReno |
| :--- | :--- | :--- | :--- |
| **核心机制** | 慢启动、拥塞避免、快速重传 | 在Tahoe基础上增加**快速恢复** | 在Reno基础上改进**快速恢复** |
| **收到3个DupACK** | `cwnd` 重置为1，进入慢启动 | 进入**快速恢复**，`cwnd = ssthresh + 3` | 同Reno，进入**快速恢复** |
| **快速恢复阶段** | **无**快速恢复阶段 | 有。收到**新数据ACK**后退出，进入拥塞避免 | 有。通过**部分确认**重传多个丢包，收到**完全ACK**后才退出 |
| **处理单个丢包** | 性能差（窗口降至1） | **性能好**（保持较高窗口） | 性能好（同Reno） |
| **处理多个丢包** | 性能差（窗口降至1） | 性能差（易导致超时） | **性能好**（避免超时） |
| **历史地位** | 早期基础版本 | 广泛应用，重要改进 | 对Reno的显著增强，曾是许多系统的默认选项 |
```
**演进脉络**：
**Tahoe**（发现丢包就重置） -> **Reno**（引入快速恢复，优雅处理单个丢包） -> **NewReno**（改进快速恢复，能处理多个丢包）。

如今，Linux等现代操作系统中默认的TCP拥塞控制算法（如CUBIC）都包含了比NewReno更先进的特性，但理解这三者的区别是掌握TCP拥塞控制演进逻辑的关键。
```
### 通过Chiu Jain图说明为什么要用AIMD
![输入图片说明](/imgs/2025-10-20/67juruncwYg4pd8C.png)CJP
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTI4NjE3NTgxNCw1OTQ2MDA3MDAsLTE1MT
AyMzAwMjcsMTU3NjAxODA4NiwxOTU1NTI3MTk0LC0xOTYwNjM5
OTQ3LDE3NDgxODY1OCwyMTM5MzcyNzUxLC00MzcyMjI3NjUsMT
U4Mjg0NDg4NywtNDI0MTMyOTcsMTI0MDk3NTk3MSwtNzMzNjM0
Mzk4LDUwMjk2NTU1OSwtMzMwMTM5OTY0LC0xNDU4OTEyMDgyLD
E4NTIzNjI3MzYsNjczMTc4MzAwLC0xNTkwOTk2NjM1LDc1OTg1
MDA0Ml19
-->