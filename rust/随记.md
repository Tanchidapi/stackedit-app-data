### 变量
- 变量默认是不可修改的值，需要修改要在声明时加关键字mut（mutable）
- 常量定义时需要写类型
`（常量表达式：const xxx: type = value）`，常量和不可变变量的区别在于作用域，常量的值可以是表达式，但必须是可以提前算出的
### 基本数据类型
![输入图片说明](/imgs/2025-12-25/WTGYrmkEt8watZpI.png)如图
变量声明时可以省略类型，如果写全的话就是`let xxx: type = value`
数组类型是在栈上分配的已知固定大小的单个内存块，元组内数据类型可以不一样，数组则不行
数组还有一种写法为`[x;y]`意为创建y个值为x的数组

上述所有的基本数据类型都是在栈上的，标量类型都实现了复制操作，复合类型根据其中装载的元素决定是否实现复制操作
此外还有特殊数据类型：切片和字符串，切片数据在堆/静态区，本身在栈上，字符串数据在堆，元数据在栈上，两者都没有实现复制操作，因此对应值的所有权转移时原变量会失效

对于无符号整数类型，编译器在debug模式下会检查溢出，但是使用参数`--release`参数构建时不会检查，对于可能的溢出可以用wrapping系列的方法显式处理
反之，对于左右移运算符时钟会检查溢出

rust中的浮点数运算和c类似，注意不能直接判断相等，本质还是IEEE-754下的存储方法导致二进制表示的浮点数不是绝对精确的
在`.toml`文件中添加依赖库`num`，并在对应使用的文件中添加代码`use num::complex::Complex;`即可使用高精度的浮点数和复数及其相等判断操作

rust中的类型转换必须是显式的，使用as关键字

rust中，所有的Unicode的值都可以作为字符，占4字节

bool型占1字节

单元类型`()`是一种特殊的类型，常用于main函数的返回值`fn main()`，无返回值的函数在rust中是有单独定义的：`发散函数( diverging functions )`，顾名思义，无法收敛的函数。还有常见的`println!()`的返回值也是单元类型，单元类型还有一种用法是占位符，如可以用于map中的值，这种情况下我们只关心键而不关心值，并且值不占用任何内存
### 函数
格式为`fn name(param list) -> return value { body }`
![输入图片说明](/imgs/2025-12-29/UXNppmGAUVkTuYuZ.png)

### if表达式
判别式不需要加括号，其余与c一致
因为if是表达式，因此也可以用于赋值语句，例如`let xxx = if condition { value1 } else { value2 };`
### 循环
使用loop关键字，在循环体中使用break退出循环或者continue开启下一次循环
和if类似，loop的结果也可以作为返回值，在break后写明即可
循环标签写在loop前，如`lable: loop`，然后将标签和break/continue一起使用来指明跳转的循环
while循环和c类似，同样无括号
for循环和python类似，常用于容器遍历，还有一种写法为`for x in 0..100`，表示x从0到99（左闭右开）遍历，用`for x in 0..=100`实现左闭右闭
使用类似于`1..100`这种语句生成序列时，要求内容为数字或者字符类型，即可以检查序列是否为空的连续类型
### 所有权
- 每个值都有一个所有者
- 值任意时刻有且只有一个所有者
- 当所有者（变量）离开作用域，这个值将被丢弃
- 
变量从声明的点开始到作用域结束都是有效的
可以定义与先前变量同名的新变量，第一个变量将被第二个变量隐藏（shadowing），变量间的隐藏关系需要注意作用域

整数和字符串的所有权转换是有区别的，整数默认拷贝操作（因为在栈上，进行值拷贝开销很小），而字符串默认**转移**（其由存储在栈上的堆指针、字符串长度、字符串容量共同组成），转移会使原变量（所有者）失效，可以通过显示调用`.clone()`来实现深拷贝，但比起移动开销更大
在代码中要特别注意字符串所有权的转移
要注意函数参数的类型以判断所有权的转换
进一步的，因为所有的基本类型都是存储在栈上的，因此都是以拷贝的方式操作的，所有自动的拷贝操作都是浅拷贝
### 引用与借用
引用更像一个指针，它是一个地址，可用由此访问存储于该地址的其他变量的数据。与指针不同，引用确保指向某个特定类型的有效值。引用不会转换所有权，也没有所有权，将创建一个引用的行为称为借用，使用引用时类似c，需要解引用`*`
默认引用不能改变对象的值，可使用可变引用
- 不变引用可用同时有多个（读者共存）
- 不变引用和可变引用不能同时存在（读写互斥）
- 不变引用不能同时存在多个（读读互斥）
很多时候，大括号可以解决一些编译不通过的问题，即通过手动限制变量的作用域

悬垂引用也叫做悬垂指针，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。在 Rust 中编译器可以确保引用永远也不会变成悬垂状态：当你获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用。
### slice切片
slice允许引用集合中一段连续的元素序列，而不是整个集合，因为是引用所以没有所有权
对于字符串而言，切片就是对String类型中某一部分的引用。对字符串使用切片语法时需要小心，切片的索引必须落在字符串的边界位置，也就是UTF-8字符的边界，如中文在UTF-8中就占3字节，因此如果要对中文字符串取切片的话，索引一定要满足长度和边界为3的倍数，总之，对字符串切片是一个很危险的操作，需要注意
### 结构体
和c类似，使用结构体要通过为其每个字段指定具体值来创建实例，实例中字段的顺序不需要和结构体中定义的一致
定义语法为`struct x { name: type, ··· }`
创建实例操作`let y = x { name: value, ··· };`
可以通过`.`操作符根据名称访问结构体中的字段，如果要修改，整个结构体实例变量都要声明为可变的
用函数方式构建结构体实例时，传入的参数名如果和结构体字段同名则可以缩略
结构体更新语法允许通过一个已有的结构体来初始化另一个结构体，在构建内部使用`..已有结构体实例名`，即可，注意更新语法后不能加逗号，其他字段均可加，凡是没有显式声明的字段，均与已有的结构体一致，需要注意，如果字段中有字符串，则会发生所有权转移，原结构体实例的相关字段不再可用，而其他基本类型字段会发生拷贝，可用继续使用
在结构体中往往会使用自身拥有所有权的String类型而不是引用类型，因为希望结构体拥有它所有的数据，而不是去借用，如果要使用引用类型，则需要说明其生命周期，生命周期可以确保结构体作用范围比它借用的数据的作用范围小

打印结构体信息需要用`#[derive(Debug)]` 对结构体进行标记，这样才能使用 `println!("{:?}", s);` 的方式对其进行打印输出
当结构体较大时，我们可能希望能够有更好的输出表现，此时可以使用 `{:#?}` 来替代 `{:?}`
还有一个简单的输出 debug 信息的方法，那就是使用 `dbg!` 宏，它会拿走表达式的所有权，然后打印出相应的文件名、行号等 debug 信息，当然还有我们需要的表达式的求值结果。**除此之外，它最终还会把表达式值的所有权返回**，使用方法同`println!`
`dbg!` 输出到标准错误输出 `stderr`，而 `println!` 输出到标准输出 `stdout`。

元组结构体是一种特殊的结构体，其字段没有名称，但结构体整体有名称

单元结构体和单元类型类似，可用于定义一个类型，但是不关心其内容，只关心其行为
### 关于println
使用`{}`来作为占位符。println后面的`!`是一个宏操作符，是一种特殊类型的函数。`!`作为返回值时代表一个永不返回的函数，往往用于会导致程序崩溃的函数
### 语句和表达式
Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值
语句会执行一些操作但是不会返回一个值，而表达式会在求值后返回一个值，因此在上述函数体的三行代码中，前两行是语句，最后一行是表达式。

对于 Rust 语言而言，**这种基于语句（statement）和表达式（expression）的方式是非常重要的，你需要能明确的区分这两个概念**，但是对于很多其它语言而言，这两个往往无需区分。基于表达式是函数式语言的重要特征，**表达式总要返回值**。

调用一个函数是表达式，因为会返回一个值，调用宏也是表达式，用花括号包裹最终返回一个值的语句块也是表达式，总之，能返回值，它就是表达式

表达式和语句的最大区别在于分号，如果表达式最后不返回任何值，则会隐式的返回一个单元类型
### 字符串String
rust中的字符串被分配到堆上，可以动态伸缩，通过使用`String::from("xxx")`来使用字符串对象，如果直接使用字符串给某一变量赋值，使用的则是字面字符串（存储在只读数据段），该变量本质上是该字面字符串的一个引用，也不能动态伸缩。
字符串的字面量可以看作是切片指向了程序可执行文件中的某个点，因此是一个不可变引用

rust中字符串不是简单的把字符串起来，字符是Unicode类型，占4字节，字符串用的是UTF-8编码，所占字节数是变化的，有利于减少占有空间

Rust 在语言级别，只有一种字符串类型： `str`，它通常是以引用类型出现 `&str`，也就是上文提到的字符串切片。虽然语言级别只有上述的 `str` 类型，但是在标准库里，还有多种不同用途的字符串类型，其中使用最广的即是 `String` 类型。

`str` 类型是硬编码进可执行文件，也无法被修改，但是 `String` 则是一个可增长、可改变且具有所有权的 UTF-8 编码字符串，当 Rust 用户提到字符串时，往往指的就是 `String` 类型和 `&str` 字符串切片类型，这两个类型都是 UTF-8 编码。
由于字符串编码的特性，rust不允许去索引字符串

str转String可以用`String::from("xxx")`或者`"xxx".to_string()`，而String转str直接用切片即可

在字符串尾部可以使用 `push()` 方法追加字符 `char`，也可以使用 `push_str()` 方法追加字符串字面量。这两个方法都是**在原有的字符串上追加，并不会返回新的字符串**。由于字符串追加操作要修改原来的字符串，则该字符串必须是可变的，即**字符串变量必须由 `mut` 关键字修饰**。

可以使用 `insert()` 方法插入单个字符 `char`，也可以使用 `insert_str()` 方法插入字符串字面量，与 `push()` 方法不同，这俩方法需要传入两个参数，第一个参数是字符（串）插入位置的索引，第二个参数是要插入的字符（串），索引从 0 开始计数，如果越界则会发生错误。由于字符串插入操作要**修改原来的字符串**，则该字符串必须是可变的，即**字符串变量必须由 `mut` 关键字修饰**。

如果想要把字符串中的某个字符串替换成其它的字符串，那可以使用 `replace()` 方法。与替换有关的方法有三个。
1、`replace`
该方法可适用于 `String` 和 `&str` 类型。`replace()` 方法接收两个参数，第一个参数是要被替换的字符串，第二个参数是新的字符串。该方法会替换所有匹配到的字符串。**该方法是返回一个新的字符串，而不是操作原来的字符串**。
2、`replacen`
该方法可适用于 `String` 和 `&str` 类型。`replacen()` 方法接收三个参数，前两个参数与 `replace()` 方法一样，第三个参数则表示替换的个数。**该方法是返回一个新的字符串，而不是操作原来的字符串**。
3、`replace_range`
该方法仅适用于 `String` 类型。`replace_range` 接收两个参数，第一个参数是要替换字符串的范围（Range），第二个参数是新的字符串。**该方法是直接操作原来的字符串，不会返回新的字符串。该方法需要使用 `mut` 关键字修饰**。

与字符串删除相关的方法有 4 个，它们分别是 `pop()`，`remove()`，`truncate()`，`clear()`。这四个方法仅适用于 `String` 类型。
1、 `pop` —— 删除并返回字符串的最后一个字符
**该方法是直接操作原来的字符串**。但是存在返回值，其返回值是一个 `Option` 类型，如果字符串为空，则返回 `None`。
2、 `remove` —— 删除并返回字符串中指定位置的字符
**该方法是直接操作原来的字符串**。但是存在返回值，其返回值是删除位置的字符串，只接收一个参数，表示该字符起始索引位置。`remove()` 方法是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误。
3、`truncate` —— 删除字符串中从指定位置开始到结尾的全部字符
**该方法是直接操作原来的字符串**。无返回值。该方法 `truncate()` 方法是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误。
4、`clear` —— 清空字符串
**该方法是直接操作原来的字符串**。调用后，删除字符串中的所有字符，相当于 `truncate()` 方法参数为 0 的时候。

**连接 (Concatenate)**
1、使用 `+` 或者 `+=` 连接字符串
使用 `+` 或者 `+=` 连接字符串，要求右边的参数必须为字符串的切片引用（Slice）类型。其实当调用 `+` 的操作符时，相当于调用了 `std::string` 标准库中的 [`add()`]方法，这里 `add()` 方法的第二个参数是一个引用的类型。因此我们在使用 `+` 时， 必须传递切片引用类型。不能直接传递 `String` 类型。**`+` 是返回一个新的字符串，所以变量声明可以不需要 `mut` 关键字修饰**。
2、使用 `format!` 连接字符串
`format!` 这种方式适用于 `String` 和 `&str` 。`format!` 的用法与 `print!` 的用法类似
### 元组
是多种类型组合到一起形成的，因此是复合类型，长度固定，其中元素顺序也固定
可以用模式匹配或者`.`操作符来获取元组中的值，`.`操作符类似访问索引
可以利用元组来返回多个值
### 枚举
**枚举类型是一个类型，它会包含所有可能的枚举成员，而枚举值是该类型中的具体某个成员的实例。**
可以通过`::`操作符来访问枚举类型的成员实例

和c的枚举类型不同，rust的枚举成员可以持有自己的数据类型，如
```rust
enum PokerCard { 
	Clubs(u8),
	Spades(u8),
	Diamonds(u8), 
	Hearts(u8), 
}
fn main() { 
	let c1 = PokerCard::Spades(5);
	let c2 = PokerCard::Diamonds(13); }
```
进一步的，枚举成员还可以是结构体，任何类型的数据都可以放入枚举成员中，枚举有一点像联合体，但不完全是

rust中用`Option`枚举来处理空值，`Option` 枚举包含两个成员，一个成员表示含有值：`Some(T)`, 另一个表示没有值：`None`，定义如下：
`enum Option<T> {     Some(T),     None, }`
其中 `T` 是泛型参数，`Some(T)`表示该枚举成员的数据类型是 `T`，换句话说，`Some` 可以包含任何类型的数据。
Option在标准库中已经提前引入，无需使用 `Option::` 前缀就可直接使用 `Some` 和 `None`
如果使用 `None` 而不是 `Some`，需要告诉 Rust `Option<T>` 是什么类型的，因为编译器只通过 `None` 值无法推断出 `Some` 成员保存的值的类型。
Option比空值的优势在于，`Option<T>` 和 `T`（这里 `T` 可以是任何类型）是不同的类型
当在 Rust 中拥有一个像 `i8` 这样类型的值时，编译器确保它总是有一个有效的值，我们可以放心使用而无需做空值检查。只有当使用 `Option<i8>`（或者任何用到的类型）的时候才需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。
换句话说，在对 `Option<T>` 进行 `T` 的运算之前必须将其转换为 `T`。通常这能帮助我们捕获到空值最常见的问题之一：期望某值不为空但实际上为空的情况。
只要一个值不是 `Option<T>` 类型，你就 **可以** 安全的认定它的值不为空。

同样的，和结构体一样的方法添加`#[derive(Debug)]`声明来使用打印输出
### 数组
数组内为基本类型时的使用方式和c中的一致，若数组中有非基本类型如String时，
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTExMzMzMzYzODAsLTE3NDY0NzA2NDAsNj
Q1NzM1MDEzLDE5ODQ5MTQ5MzQsMTkzNTE3MjczOSw5NDQwNjkx
MDIsMzExOTM1NDQ5LC0yMDQxMzU2NTQsLTk3NzM2NzQzMywxNT
c4OTU4NTI4LC05OTY1OTAyODUsLTczNzAzMjI5MywxMTQyMzQw
NDY5LDc1MDQwODMxMiwxODI4NjEwNjcxLDE3NTkyMzAyNjcsLT
k1OTM3MDQ3MSw2MzU3OTIxNDYsLTE3MjYyNjIyMDEsLTExNDMy
ODkwNTZdfQ==
-->