### 变量
- 变量默认是不可修改的值，需要修改要在声明时加关键字mut（mutable）
- 常量定义时需要写类型
`（常量表达式：const xxx： class = value）`，常量和不可变变量的区别在于作用域，常量的值可以是表达式，但必须是可以提前算出的
### 基本数据类型
![输入图片说明](/imgs/2025-12-25/WTGYrmkEt8watZpI.png)如图
变量声明时可以省略类型，如果写全的话就是`let xxx: class = value`
数组类型是在栈上分配的已知固定大小的单个内存块，元组内数据类型可以不一样，数组则不行
数组还有一种写法为`[x;y]`意为创建y个值为x的数组

上述所有的基本数据类型都是在栈上的，标量类型都实现了复制操作，复合类型根据其中装载的元素决定是否实现复制操作
此外还有特殊数据类型：切片和字符串，切片数据在堆/静态区，本身在栈上，字符串数据在堆，元数据在栈上，两者都没有实现复制操作，因此对应值的所有权转移时原变量会失效

对于无符号整数类型，编译器在debug模式下会检查溢出，但是使用参数`--release`参数构建时不会检查，对于可能的溢出可以用wrapping系列的方法显式处理
反之，对于左右移运算符时钟会检查溢出

rust中的浮点数运算和c类似，注意不能直接判断相等，本质还是IEEE-754下的存储方法导致二进制表示的浮点数不是绝对精确的
在`.toml`文件中添加依赖库`num`，并在对应使用的文件中添加代码`use num::complex::Complex;`即可使用高精度的浮点数和复数及其相等判断操作

rust中的类型转换必须是显式的，使用as关键字

rust中，所有的Unicode的值都可以作为字符，占4字节

bool型占1字节

单元类型`()`是一种特殊的类型，常用于main函数的返回值`fn main()`，无返回值的函数在rust中是有单独定义的：`发散函数( diverging functions )`，顾名思义，无法收敛的函数。还有常见的`pr
### 函数
格式为`fn name(param list) -> return value { body }`
### if表达式
判别式不需要加括号，其余与c一致
因为if是表达式，因此也可以用于赋值语句，例如`let xxx = if condition { value1 } else { value2 };`
### 循环
使用loop关键字，在循环体中使用break退出循环或者continue开启下一次循环
和if类似，loop的结果也可以作为返回值，在break后写明即可
循环标签写在loop前，如`lable: loop`，然后将标签和break/continue一起使用来指明跳转的循环
while循环和c类似，同样无括号
for循环和python类似，常用于容器遍历，还有一种写法为`for x in 0..100`，表示x从0到99（左闭右开）遍历，用`for x in 0..=100`实现左闭右闭
使用类似于`1..100`这种语句生成序列时，要求内容为数字或者字符类型，即可以检查序列是否为空的连续类型
### 所有权
- 每个值都有一个所有者
- 值任意时刻有且只有一个所有者
- 当所有者（变量）离开作用域，这个值将被丢弃
let执行的就是一个绑定（bind）的操作，通过`let x = 123; let y = x`可以实现值的抢占，x将被废弃掉，不再使用
变量从声明的点开始到作用域结束都是有效的
可以定义与先前变量同名的新变量，第一个变量将被第二个变量隐藏（shadowing），变量间的隐藏关系需要注意作用域
整数和字符串的所有权转换是有区别的，整数默认复制操作，而字符串默认**移动**，移动会使原变量失效，可以通过显示调用`.clone()`来实现深拷贝，但比起移动开销更大
在代码中要特别注意字符串所有权的转移
要注意函数参数的类型以判断所有权的转换
### 引用与借用
引用更像一个指针，它是一个地址，可用由此访问存储于该地址的其他变量的数据。与指针不同，引用确保指向某个特定类型的有效值。引用不会转换所有权，将创建一个引用的行为称为借用
默认引用不能改变对象的值，可使用可变引用
- 不变引用可用同时有多个（读者共存）
- 不变引用和可变引用不能同时存在（读写互斥）
- 不变引用不能同时存在多个（读读互斥）
### slice
slice允许引用集合中一段连续的元素序列，而不是整个集合，因为是引用所以没有所有权，string slice的写法为变量名加上`&`
### 结构体
和c类似，使用结构体要通过为其每个字段指定具体值来创建实例，实例中字段的顺序不需要和结构体中定义的一致
### vec动态数组 hashmap映射
类似于cpp
开销比起定长数组大
### 关于println
使用`{}`来作为占位符。println后面的`!`是一个宏操作符，是一种特殊类型的函数
<!--stackedit_data:
eyJoaXN0b3J5IjpbMzY0MDgxOTEwLC0yOTUzOTgwMjAsLTgxOT
gzMDE4NSw1MzY4MjgyNCwyOTQ2MjY2NTYsMTkwNjAyOTA2MCwt
Mjg0NzA2Njc3LC0yMDg4NzQ2NjEyXX0=
-->