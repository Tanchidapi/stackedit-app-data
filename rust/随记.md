### 变量
- 变量默认是不可修改的值，需要修改要在声明时加关键字mut（mutable）
- 常量定义时需要写类型
`（常量表达式：const xxx： class = value）`，常量和不可变变量的区别在于作用域，常量的值可以是表达式，但必须是可以提前算出的
### 基本数据类型
![输入图片说明](/imgs/2025-12-25/WTGYrmkEt8watZpI.png)如图
变量声明时可以省略类型，如果写全的话就是`let xxx: class = value`
数组类型是在栈上分配的已知固定大小的单个内存块，元组内数据类型可以不一样，数组则不行
数组还有一种写法为`[x;y]`意为创建y个值为x的数组

上述所有的基本数据类型都是在栈上的，标量类型都实现了复制操作，复合类型根据其中装载的元素决定是否实现复制操作
此外还有特殊数据类型：切片和字符串，切片数据在堆/静态区，本身在栈上，字符串数据在堆，元数据在栈上，两者都没有实现复制操作，因此对应值的所有权转移时原变量会失效

对于无符号整数类型，编译器在debug模式下会检查溢出，但是使用参数`--release`参数构建时不会检查，对于可能的溢出可以用wrapping系列的方法显式处理
反之，对于左右移运算符时钟会检查溢出

rust中的浮点数运算和c类似，注意不能直接判断相等，本质还是IEEE-754下的存储方法导致二进制表示的浮点数不是绝对精确的
在`.toml`文件中添加依赖库`num`，并在对应使用的文件中添加代码`use num::complex::Complex;`即可使用高精度的浮点数和复数及其相等判断操作

rust中的类型转换必须是显式的，使用as关键字

rust中，所有的Unicode的值都可以作为字符，占4字节

bool型占1字节

单元类型`()`是一种特殊的类型，常用于main函数的返回值`fn main()`，无返回值的函数在rust中是有单独定义的：`发散函数( diverging functions )`，顾名思义，无法收敛的函数。还有常见的`println!()`的返回值也是单元类型，单元类型还有一种用法是占位符，如可以用于map中的值，这种情况下我们只关心键而不关心值，并且值不占用任何内存
### 函数
格式为`fn name(param list) -> return value { body }`
![输入图片说明](/imgs/2025-12-29/UXNppmGAUVkTuYuZ.png)

### if表达式
判别式不需要加括号，其余与c一致
因为if是表达式，因此也可以用于赋值语句，例如`let xxx = if condition { value1 } else { value2 };`
### 循环
使用loop关键字，在循环体中使用break退出循环或者continue开启下一次循环
和if类似，loop的结果也可以作为返回值，在break后写明即可
循环标签写在loop前，如`lable: loop`，然后将标签和break/continue一起使用来指明跳转的循环
while循环和c类似，同样无括号
for循环和python类似，常用于容器遍历，还有一种写法为`for x in 0..100`，表示x从0到99（左闭右开）遍历，用`for x in 0..=100`实现左闭右闭
使用类似于`1..100`这种语句生成序列时，要求内容为数字或者字符类型，即可以检查序列是否为空的连续类型
### 所有权
- 每个值都有一个所有者
- 值任意时刻有且只有一个所有者
- 当所有者（变量）离开作用域，这个值将被丢弃
- 
变量从声明的点开始到作用域结束都是有效的
可以定义与先前变量同名的新变量，第一个变量将被第二个变量隐藏（shadowing），变量间的隐藏关系需要注意作用域

整数和字符串的所有权转换是有区别的，整数默认拷贝操作（因为在栈上，进行值拷贝开销很小），而字符串默认**转移**（其由存储在栈上的堆指针、字符串长度、字符串容量共同组成），转移会使原变量（所有者）失效，可以通过显示调用`.clone()`来实现深拷贝，但比起移动开销更大
在代码中要特别注意字符串所有权的转移
要注意函数参数的类型以判断所有权的转换
进一步的，因为所有的基本类型都是存储在栈上的，因此都是以拷贝的方式操作的
### 引用与借用
引用更像一个指针，它是一个地址，可用由此访问存储于该地址的其他变量的数据。与指针不同，引用确保指向某个特定类型的有效值。引用不会转换所有权，将创建一个引用的行为称为借用
默认引用不能改变对象的值，可使用可变引用
- 不变引用可用同时有多个（读者共存）
- 不变引用和可变引用不能同时存在（读写互斥）
- 不变引用不能同时存在多个（读读互斥）
### slice
slice允许引用集合中一段连续的元素序列，而不是整个集合，因为是引用所以没有所有权，string slice的写法为变量名加上`&`
### 结构体
和c类似，使用结构体要通过为其每个字段指定具体值来创建实例，实例中字段的顺序不需要和结构体中定义的一致
### vec动态数组 hashmap映射
类似于cpp
开销比起定长数组大
### 关于println
使用`{}`来作为占位符。println后面的`!`是一个宏操作符，是一种特殊类型的函数。`!`作为返回值时代表一个永不返回的函数，往往用于会导致程序崩溃的函数
### 语句和表达式
Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值
语句会执行一些操作但是不会返回一个值，而表达式会在求值后返回一个值，因此在上述函数体的三行代码中，前两行是语句，最后一行是表达式。

对于 Rust 语言而言，**这种基于语句（statement）和表达式（expression）的方式是非常重要的，你需要能明确的区分这两个概念**，但是对于很多其它语言而言，这两个往往无需区分。基于表达式是函数式语言的重要特征，**表达式总要返回值**。

调用一个函数是表达式，因为会返回一个值，调用宏也是表达式，用花括号包裹最终返回一个值的语句块也是表达式，总之，能返回值，它就是表达式

表达式和语句的最大区别在于分号，如果表达式最后不返回任何值，则会隐式的返回一个单元类型
### 字符串String
rust中的字符串被分配到堆上，可以动态伸缩
<!--stackedit_data:
eyJoaXN0b3J5IjpbNTU0MjgyMDQwLC0xNTcwMzQ5MDEsMTk1Nj
k0NDg1NiwtMTI5NjgzNTE3OSwtMjk1Mzk4MDIwLC04MTk4MzAx
ODUsNTM2ODI4MjQsMjk0NjI2NjU2LDE5MDYwMjkwNjAsLTI4ND
cwNjY3NywtMjA4ODc0NjYxMl19
-->