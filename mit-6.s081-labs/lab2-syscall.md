# Syscall
这个实验的主要目的是通过编写两个系统调用函数来加强对系统调用的理解，其中包含了从用户态到内核态的切换过程
实验一共两题，两题在添加系统调用步骤上差不多，区别在各自的具体实现
开始作答前先解释本次实验要用到的头文件的源文件的大概作用
## /user目录下的文件
1. user.h
这个文件列出了用户态下可以调用的系统函数以及其他源文件（如ulib.c）的函数，给出函数的名称、返回类型及传参类型
2. usys.pl
这是一个perl脚本，运行后会生成.s汇编文件，里面定义了每个系统调用函数的跳板函数，会将用户态下的系统调用的id寄存器，然后执行系统调用跳到内核态同一系统调用处理函数syscall
## /kernel目录下的文件
1. syscall.h
这个文件列出了系统调用函数的一系列id，所有系统调用函数都有自己对应的唯一id
2. syscall.c
这个文件是系统调用处理的主要函数，会根据使用系统调用时传入的id，选择对应的系统函数并执行调用，也包含了获取系统函数所需参数的函数
3. sysproc.c
这个文件包含了内核态下，执行的系统函数的具体实现，即对应的系统函数怎么获取用户态传来的参数，然后如何分析并使用系统函数
4. proc.h
这个文件是对于操作系统运行时进程相关的对象的定义，如上下文，trapframe，进程，cpu的状态，由结构体的形式实现
5. proc.c
这个文件是在已有的头文件的定义上，对进程等对象的一些基础操作，如进程的初始化与分配等
6. defs.h
这个头文件定义了内核态下一系列的函数的原型，即函数名，返回值与传参类型
7. kalloc.c
这个文件包含了内核分配相关的函数的具体实现
## 系统调用流程
根据上面的文件列表及其分工我们可以看出在用户态下zhi'xi

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1NTIwODExMjYsMTU1MjY0MDkxMywtMT
AzNTYzNDM3Ml19
-->