# 6.8
## 题目一
### 金字塔搭建，给定一个金字塔底部，一系列允许的搭建方式，即连续两个字母块上方允许放置的字母块，问能否完成搭建（最高层为一个字母快）
#### eg：
```c++
>>>bottom = "BCD", allowed = ["BCC","CDE","CEA","FFF"]
true
```
本质思路为dfs，做不出来，看了几个题解都是在新测试下超时的，最新题解不想看了，选了一个时间O(n^2)的思路清晰的题解抄录，本解通过一层层构建字符串实现dfs，先构建当前层，如果还未构建完就从合法的放置块中顺序找一个放入，然后进入下一层搜索，即放当行下一块，如果这一行放完了就到下一行，
```c++
class Solution {
public:
    bool fun(string str1,string str2,vector<string>& allowed){
        if(str1.size()==1) return true;
        if(str1.size()-str2.size()>1){
            bool judge=false;
            for(string s:allowed){
                if(str1[str2.size()]==s[0]&&str1[str2.size()+1]==s[1]){
                    judge=judge||fun(str1,str2+s[2],allowed);
                }
            }
            return judge;
        }
        else return fun(str2,"",allowed);
    }
    bool pyramidTransition(string bottom, vector<string>& allowed) {
        if(bottom=="") return true;
        return fun(bottom,"",allowed);
    }
};
```


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTYzNjU5NjU5MSw5Nzc5OTYyMThdfQ==
-->