# 6.3
## 题目一
### 给定一个数组，给定上下界left、right，问数组中满足最大元素在上下界内连续子数组的个数
#### eg：
```c++
>>>nums = [2,1,4,3], left = 2, right = 3
3
```
想到了使用动态规划求解，用数组dp表示解，dp[i]表示以nums[i]结尾的满足题意的子数组个数，但考虑到在小于下界时会出现dp值为0，但下一个数满足条件，dp值计算要用到前面可能出现的n个连续的小于下界的数的dp值，会出现问题，因此再用一个数组less记录小于下界的连续子数组个数，题解如下：
```c++
class Solution {
public:
	int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {
		int counter = 0;
		int len = nums.size();
		int dp[len], less[len];
		memset(dp, 0, sizeof(dp));
		memset(less, 0, sizeof(dp));
		for(int i = 0; i < len; i++){
			if(nums[i] >= left && nums[i] <= right){
				if(i)
					dp[i] = dp[i - 1] + less[i - 1] + 1;
				else dp[i] = 1;
			}
			else if(nums[i] < left){
				if(i){
					dp[i] = dp[i - 1];
					less[i] = 1 + less[i - 1];
				}
				else less[i] = 1;
			}
			counter += dp[i];
		}
		return counter;
	}
};
```
上述代码时间复杂度O(n)，最优，但是空间复杂度较差，在评论区看到惊艳题解，如下：
```c++
class Solution { 
public:
	int numSubarrayBoundedMax(vector<int>& A, int L, int R) { 
		int j = -1, temp = 0, ans = 0;
		for(int i = 0; i < A.size(); i++){
			if(A[i] > R) j = i;
			if(A[i] >= L) temp = i - j;
			ans += temp;
		}
		return ans;
	}
};
```
j为大于上界的数的xia'biao
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjc1ODY0MTMsLTY1ODY5MDM1NF19
-->