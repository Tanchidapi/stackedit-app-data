# 6.3
## 题目一
### 给定一个数组，给定上下界left、right，问数组中满足最大元素在上下界内连续子数组的个数
#### eg：
```c++
>>>nums = [2,1,4,3], left = 2, right = 3
3
```
想到了使用动态规划求解，用数组dp表示解，dp[i]表示以nums[i]结尾的满足题意的子数组个数，但考虑到在小于下界时会出现dp值为0，但下一个数满足条件，dp值计算要用到前面可能出现的n个连续的小于下界的数的dp值，会出现问题，因此再用一个数组less记录小于下界的连续子数组个数，题解如下：
```c++
class Solution {
public:
	int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {
		int counter = 0;
		int len = nums.size();
		int dp[len], less[len];
		memset(dp, 0, sizeof(dp));
		memset(less, 0, sizeof(dp));
		for(int i = 0; i < len; i++){
			if(nums[i] >= left && nums[i] <= right){
				if(i)
					dp[i] = dp[i - 1] + less[i - 1] + 1;
				else dp[i] = 1;
			}
			else if(nums[i] < left){
				if(i){
					dp[i] = dp[i - 1];
					less[i] = 1 + less[i - 1];
				}
				else less[i] = 1;
			}
			counter += dp[i];
		}
		return counter;
	}
};
```
上述代码时间复杂度O(n)，最优，但是空间复杂度较差，在评论区看到惊艳题解，如下：
```c++
class Solution { 
public:
	int numSubarrayBoundedMax(vector<int>& A, int L, int R) { 
		int j = -1, temp = 0, ans = 0, len = A.size();
		for(int i = 0; i < len; i++){
			if(A[i] > R) j = i;
			if(A[i] >= L) temp = i - j;
			ans += temp;
		}
		return ans;
	}
};
```
j为大于上界的数的下标，大于上界的数肯定不能被放入子数组中，且会将整个数组划分为两部分分析，在j之后找在要求范围内的数，如果找到了，那么以这个数为结尾的子数组个数就是其下标减去往前最近的大于上界的数的下标，是dp的优化版。
## 题目二
### 
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTczMTUyOTgxNCwtNjU4NjkwMzU0XX0=
-->